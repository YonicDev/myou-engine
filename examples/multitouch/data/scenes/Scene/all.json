[{"background_color": [0.05087608844041824, 0.05087608844041824, 0.05087608844041824], "name": "Scene", "gravity": [0, 0, -9.800000190734863], "ambient_color": [0.0, 0.0, 0.0], "frame_start": 1, "fps": 24, "stereo_eye_separation": 0.10000000149011612, "active_camera": "Camera", "stereo": false, "debug_physics": false, "frame_end": 100, "type": "SCENE"},{"scene": "Scene", "uv_multiplier": 1.0, "offset_scale": [0.9999998807907104, 0.9999999403953552, 0.9999999403953552], "materials": ["wood"], "pos": [-0.6209187507629395, -11.19704818725586, 3.389460325241089], "name": "wall_front", "actions": [], "properties": {}, "friction_coefficients": [1.0, 1.0, 1.0], "collision_compound": false, "parent_bone": "", "collision_mask": 255, "linear_factor": [1, 1, 1], "phy_type": "STATIC", "radius": 1.0, "avg_poly_area": 0.3084847529729207, "color": [0.9849011898040771, 1.0, 0.969936192035675, 1.0], "dimensions": [9.966717720031738, 9.966717720031738, 4.240382671356201], "form_factor": 0.4000000059604645, "elasticity": 0.0, "passes": [0], "stride": 28, "shape_multiplier": 1.0, "mesh_name": "wall", "rot": [5.591469403043448e-07, 5.591475655819522e-07, 0.7071071863174438, 0.707106351852417], "no_sleeping": false, "mass": 1.0, "visible": true, "dupli_group": null, "lod_levels": [], "offsets": [0, 0, 168, 36], "zindex": 1, "friction": 0.5, "collision_bounds_type": "BOX", "hash": "f0ff695a6ccd7bd381652e4499970f76f8c8f779", "anisotropic_friction": false, "angular_factor": [1, 1, 1], "is_ghost": false, "scale": [9.966717720031738, 9.966717720031738, 9.966717720031738], "all_f": false, "parent": null, "type": "MESH", "collision_margin": 0.03999999910593033, "rot_mode": "Q", "collision_group": 2, "elements": [["normal"], ["tangent"], ["uv", "UVMap"]]},{"scene": "Scene", "uv_multiplier": 1.0, "offset_scale": [1.0, 0.9999999403953552, 1.0], "materials": ["wood"], "pos": [6.242065906524658, -2.387599229812622, 3.389460325241089], "name": "wall_right", "actions": [], "properties": {}, "friction_coefficients": [1.0, 1.0, 1.0], "collision_compound": false, "parent_bone": "", "collision_mask": 255, "linear_factor": [1, 1, 1], "phy_type": "STATIC", "radius": 1.0, "avg_poly_area": 0.3084847529729207, "color": [0.9849011898040771, 1.0, 0.969936192035675, 1.0], "dimensions": [14.34070110321045, 9.966717720031738, 4.240382671356201], "form_factor": 0.4000000059604645, "elasticity": 0.0, "passes": [0], "stride": 28, "shape_multiplier": 1.0, "mesh_name": "wall", "rot": [0.49999961256980896, 0.5000001192092896, -0.5000003576278687, -0.49999988079071045], "no_sleeping": false, "mass": 1.0, "visible": true, "dupli_group": null, "lod_levels": [], "offsets": [0, 0, 168, 36], "zindex": 1, "friction": 0.5, "collision_bounds_type": "BOX", "hash": "f0ff695a6ccd7bd381652e4499970f76f8c8f779", "anisotropic_friction": false, "angular_factor": [1, 1, 1], "is_ghost": false, "scale": [14.34070110321045, 9.966717720031738, 9.966717720031738], "all_f": false, "parent": null, "type": "MESH", "collision_margin": 0.03999999910593033, "rot_mode": "Q", "collision_group": 2, "elements": [["normal"], ["tangent"], ["uv", "UVMap"]]},{"scene": "Scene", "uv_multiplier": 1.0, "offset_scale": [0.9999999403953552, 1.0, 0.9999999403953552], "materials": ["wood"], "pos": [-7.530557632446289, -2.361780881881714, 3.389460325241089], "name": "wall_left", "actions": [], "properties": {}, "friction_coefficients": [1.0, 1.0, 1.0], "collision_compound": false, "parent_bone": "", "collision_mask": 255, "linear_factor": [1, 1, 1], "phy_type": "STATIC", "radius": 1.0, "avg_poly_area": 0.3084847529729207, "color": [0.9849011898040771, 1.0, 0.969936192035675, 1.0], "dimensions": [14.773139953613281, 9.966717720031738, 4.240382671356201], "form_factor": 0.4000000059604645, "elasticity": 0.0, "passes": [0], "stride": 28, "shape_multiplier": 1.0, "mesh_name": "wall", "rot": [0.4999994933605194, 0.5, 0.5000004768371582, 0.5], "no_sleeping": false, "mass": 1.0, "visible": true, "dupli_group": null, "lod_levels": [], "offsets": [0, 0, 168, 36], "zindex": 1, "friction": 0.5, "collision_bounds_type": "BOX", "hash": "f0ff695a6ccd7bd381652e4499970f76f8c8f779", "anisotropic_friction": false, "angular_factor": [1, 1, 1], "is_ghost": false, "scale": [14.773139953613281, 9.966717720031738, 9.966717720031738], "all_f": false, "parent": null, "type": "MESH", "collision_margin": 0.03999999910593033, "rot_mode": "Q", "collision_group": 2, "elements": [["normal"], ["tangent"], ["uv", "UVMap"]]},{"scene": "Scene", "uv_multiplier": 1.0, "offset_scale": [1.0, 1.0000001192092896, 1.0000001192092896], "materials": ["wood"], "pos": [-0.6264052391052246, 6.235019207000732, 3.389460325241089], "name": "wall_back", "actions": [], "properties": {}, "friction_coefficients": [1.0, 1.0, 1.0], "collision_compound": false, "parent_bone": "", "collision_mask": 255, "linear_factor": [1, 1, 1], "phy_type": "STATIC", "radius": 1.0, "avg_poly_area": 0.3084847529729207, "color": [0.9849011898040771, 1.0, 0.969936192035675, 1.0], "dimensions": [9.966717720031738, 9.966717720031738, 4.240382671356201], "form_factor": 0.4000000059604645, "elasticity": 0.0, "passes": [0], "stride": 28, "shape_multiplier": 1.0, "mesh_name": "wall", "rot": [0.7071064710617065, 0.7071070671081543, 0.0, 0.0], "no_sleeping": false, "mass": 1.0, "visible": true, "dupli_group": null, "lod_levels": [], "offsets": [0, 0, 168, 36], "zindex": 1, "friction": 0.5, "collision_bounds_type": "BOX", "hash": "f0ff695a6ccd7bd381652e4499970f76f8c8f779", "anisotropic_friction": false, "angular_factor": [1, 1, 1], "is_ghost": false, "scale": [9.966717720031738, 9.966717720031738, 9.966717720031738], "all_f": false, "parent": null, "type": "MESH", "collision_margin": 0.03999999910593033, "rot_mode": "Q", "collision_group": 2, "elements": [["normal"], ["tangent"], ["uv", "UVMap"]]},{"scene": "Scene", "uv_multiplier": 1.0, "offset_scale": [0.9999998807907104, 0.9999998211860657, 1.0], "materials": ["wood"], "pos": [0.7551977634429932, -3.4460482597351074, 2.7053680419921875], "name": "box", "actions": [], "properties": {}, "friction_coefficients": [1.0, 1.0, 1.0], "collision_compound": false, "parent_bone": "", "collision_mask": 255, "linear_factor": [1, 1, 1], "phy_type": "RIGID_BODY", "radius": 1.0, "avg_poly_area": 0.15204958071593533, "color": [0.2695600092411041, 0.3671903610229492, 1.0, 1.0], "dimensions": [1.1936376094818115, 1.1936379671096802, 1.193637490272522], "form_factor": 0.4000000059604645, "elasticity": 0.0, "passes": [0], "stride": 28, "shape_multiplier": 1.0, "mesh_name": "box", "rot": [0.4187457263469696, 0.7814332842826843, -0.0791984423995018, 0.4557868540287018], "no_sleeping": true, "mass": 1.0, "visible": true, "dupli_group": null, "lod_levels": [], "offsets": [0, 0, 672, 132], "zindex": 1, "friction": 0.5, "collision_bounds_type": "BOX", "hash": "896fb455acf4b4e8d4c70694daf5ff068f4cb8d4", "anisotropic_friction": false, "angular_factor": [1, 1, 1], "is_ghost": false, "scale": [1.0925374031066895, 1.0925376415252686, 1.0925374031066895], "all_f": false, "parent": null, "type": "MESH", "collision_margin": 0.03999999910593033, "rot_mode": "Q", "collision_group": 1, "elements": [["normal"], ["tangent"], ["uv", "UVMap"]]},{"scene": "Scene", "uv_multiplier": 1.0, "offset_scale": [1.0000001192092896, 1.0, 1.0], "materials": ["wood"], "pos": [-0.44278278946876526, -1.411510944366455, 2.628166675567627], "name": "box.001", "actions": [], "properties": {}, "friction_coefficients": [1.0, 1.0, 1.0], "collision_compound": false, "parent_bone": "", "collision_mask": 255, "linear_factor": [1, 1, 1], "phy_type": "RIGID_BODY", "radius": 1.0, "avg_poly_area": 0.15204958071593533, "color": [1.0, 0.5506851673126221, 0.027008961886167526, 1.0], "dimensions": [1.1936376094818115, 1.1936376094818115, 1.193637490272522], "form_factor": 0.4000000059604645, "elasticity": 0.0, "passes": [0], "stride": 28, "shape_multiplier": 1.0, "mesh_name": "box", "rot": [0.9287685751914978, 0.058410871773958206, -0.359860360622406, 0.06691677123308182], "no_sleeping": true, "mass": 1.0, "visible": true, "dupli_group": null, "lod_levels": [], "offsets": [0, 0, 672, 132], "zindex": 1, "friction": 0.5, "collision_bounds_type": "BOX", "hash": "896fb455acf4b4e8d4c70694daf5ff068f4cb8d4", "anisotropic_friction": false, "angular_factor": [1, 1, 1], "is_ghost": false, "scale": [1.0925374031066895, 1.0925372838974, 1.0925374031066895], "all_f": false, "parent": null, "type": "MESH", "collision_margin": 0.03999999910593033, "rot_mode": "Q", "collision_group": 1, "elements": [["normal"], ["tangent"], ["uv", "UVMap"]]},{"scene": "Scene", "uv_multiplier": 1.0, "offset_scale": [1.0, 1.0, 1.0], "materials": ["wood"], "pos": [-1.7477669715881348, -4.21139669418335, 0.9462100267410278], "name": "box.020", "actions": [], "properties": {}, "friction_coefficients": [1.0, 1.0, 1.0], "collision_compound": false, "parent_bone": "", "collision_mask": 255, "linear_factor": [1, 1, 1], "phy_type": "RIGID_BODY", "radius": 1.0, "avg_poly_area": 0.15204958071593533, "color": [1.0, 0.22026363015174866, 0.3961241841316223, 1.0], "dimensions": [1.0925370454788208, 1.0925371646881104, 1.0925369262695312], "form_factor": 0.4000000059604645, "elasticity": 0.0, "passes": [0], "stride": 28, "shape_multiplier": 1.0, "mesh_name": "box", "rot": [0.9310575127601624, 0.25906339287757874, -0.22958002984523773, 0.11537376791238785], "no_sleeping": true, "mass": 1.0, "visible": true, "dupli_group": null, "lod_levels": [], "offsets": [0, 0, 672, 132], "zindex": 1, "friction": 0.5, "collision_bounds_type": "BOX", "hash": "896fb455acf4b4e8d4c70694daf5ff068f4cb8d4", "anisotropic_friction": false, "angular_factor": [1, 1, 1], "is_ghost": false, "scale": [1.0, 1.0, 1.0], "all_f": false, "parent": null, "type": "MESH", "collision_margin": 0.03999999910593033, "rot_mode": "Q", "collision_group": 1, "elements": [["normal"], ["tangent"], ["uv", "UVMap"]]},{"scene": "Scene", "uv_multiplier": 1.0, "offset_scale": [0.9999998807907104, 1.0, 0.9999999403953552], "materials": ["wood"], "pos": [-3.2632479667663574, -3.228484869003296, 2.7502241134643555], "name": "box.019", "actions": [], "properties": {}, "friction_coefficients": [1.0, 1.0, 1.0], "collision_compound": false, "parent_bone": "", "collision_mask": 255, "linear_factor": [1, 1, 1], "phy_type": "RIGID_BODY", "radius": 1.0, "avg_poly_area": 0.15204958071593533, "color": [0.18419227004051208, 1.0, 0.7569334506988525, 1.0], "dimensions": [1.1936373710632324, 1.193637490272522, 1.1936372518539429], "form_factor": 0.4000000059604645, "elasticity": 0.0, "passes": [0], "stride": 28, "shape_multiplier": 1.0, "mesh_name": "box", "rot": [0.9507845640182495, 0.021376052871346474, -0.3062562346458435, 0.04194121062755585], "no_sleeping": true, "mass": 1.0, "visible": true, "dupli_group": null, "lod_levels": [], "offsets": [0, 0, 672, 132], "zindex": 1, "friction": 0.5, "collision_bounds_type": "BOX", "hash": "896fb455acf4b4e8d4c70694daf5ff068f4cb8d4", "anisotropic_friction": false, "angular_factor": [1, 1, 1], "is_ghost": false, "scale": [1.0925371646881104, 1.0925371646881104, 1.0925371646881104], "all_f": false, "parent": null, "type": "MESH", "collision_margin": 0.03999999910593033, "rot_mode": "Q", "collision_group": 1, "elements": [["normal"], ["tangent"], ["uv", "UVMap"]]},{"scene": "Scene", "uv_multiplier": 1.0, "offset_scale": [1.0, 1.0, 1.0], "materials": ["wood"], "pos": [0.2931634783744812, -0.23521865904331207, 4.104060649871826], "name": "box.018", "actions": [], "properties": {}, "friction_coefficients": [1.0, 1.0, 1.0], "collision_compound": false, "parent_bone": "", "collision_mask": 255, "linear_factor": [1, 1, 1], "phy_type": "RIGID_BODY", "radius": 1.0, "avg_poly_area": 0.15204958071593533, "color": [0.48077717423439026, 1.0, 0.5173617005348206, 1.0], "dimensions": [1.1936372518539429, 1.193637490272522, 1.1936372518539429], "form_factor": 0.4000000059604645, "elasticity": 0.0, "passes": [0], "stride": 28, "shape_multiplier": 1.0, "mesh_name": "box", "rot": [0.7785245776176453, 0.21234937012195587, -0.5658875107765198, 0.1690518856048584], "no_sleeping": true, "mass": 1.0, "visible": true, "dupli_group": null, "lod_levels": [], "offsets": [0, 0, 672, 132], "zindex": 1, "friction": 0.5, "collision_bounds_type": "BOX", "hash": "896fb455acf4b4e8d4c70694daf5ff068f4cb8d4", "anisotropic_friction": false, "angular_factor": [1, 1, 1], "is_ghost": false, "scale": [1.0925370454788208, 1.0925371646881104, 1.0925371646881104], "all_f": false, "parent": null, "type": "MESH", "collision_margin": 0.03999999910593033, "rot_mode": "Q", "collision_group": 1, "elements": [["normal"], ["tangent"], ["uv", "UVMap"]]},{"scene": "Scene", "uv_multiplier": 1.0, "offset_scale": [0.9999998807907104, 1.0, 0.9999999403953552], "materials": ["wood"], "pos": [0.4402275085449219, -3.220968008041382, 4.639638423919678], "name": "box.017", "actions": [], "properties": {}, "friction_coefficients": [1.0, 1.0, 1.0], "collision_compound": false, "parent_bone": "", "collision_mask": 255, "linear_factor": [1, 1, 1], "phy_type": "RIGID_BODY", "radius": 1.0, "avg_poly_area": 0.15204958071593533, "color": [0.1906442642211914, 0.10852302610874176, 1.0, 1.0], "dimensions": [1.1936373710632324, 1.193637490272522, 1.1936372518539429], "form_factor": 0.4000000059604645, "elasticity": 0.0, "passes": [0], "stride": 28, "shape_multiplier": 1.0, "mesh_name": "box", "rot": [0.9507845640182495, 0.021376052871346474, -0.3062562346458435, 0.04194121062755585], "no_sleeping": true, "mass": 1.0, "visible": true, "dupli_group": null, "lod_levels": [], "offsets": [0, 0, 672, 132], "zindex": 1, "friction": 0.5, "collision_bounds_type": "BOX", "hash": "896fb455acf4b4e8d4c70694daf5ff068f4cb8d4", "anisotropic_friction": false, "angular_factor": [1, 1, 1], "is_ghost": false, "scale": [1.0925371646881104, 1.0925371646881104, 1.0925371646881104], "all_f": false, "parent": null, "type": "MESH", "collision_margin": 0.03999999910593033, "rot_mode": "Q", "collision_group": 1, "elements": [["normal"], ["tangent"], ["uv", "UVMap"]]},{"scene": "Scene", "uv_multiplier": 1.0, "offset_scale": [1.0000001192092896, 1.0, 1.0], "materials": ["wood"], "pos": [-2.4767165184020996, -1.6428799629211426, 5.402366638183594], "name": "box.016", "actions": [], "properties": {}, "friction_coefficients": [1.0, 1.0, 1.0], "collision_compound": false, "parent_bone": "", "collision_mask": 255, "linear_factor": [1, 1, 1], "phy_type": "RIGID_BODY", "radius": 1.0, "avg_poly_area": 0.15204958071593533, "color": [0.09534817934036255, 0.32486680150032043, 1.0, 1.0], "dimensions": [1.193637490272522, 1.1936370134353638, 1.1936368942260742], "form_factor": 0.4000000059604645, "elasticity": 0.0, "passes": [0], "stride": 28, "shape_multiplier": 1.0, "mesh_name": "box", "rot": [0.9100008010864258, -0.07224526256322861, -0.38049644231796265, -0.1479928344488144], "no_sleeping": true, "mass": 1.0, "visible": true, "dupli_group": null, "lod_levels": [], "offsets": [0, 0, 672, 132], "zindex": 1, "friction": 0.5, "collision_bounds_type": "BOX", "hash": "896fb455acf4b4e8d4c70694daf5ff068f4cb8d4", "anisotropic_friction": false, "angular_factor": [1, 1, 1], "is_ghost": false, "scale": [1.0925372838974, 1.0925368070602417, 1.0925369262695312], "all_f": false, "parent": null, "type": "MESH", "collision_margin": 0.03999999910593033, "rot_mode": "Q", "collision_group": 1, "elements": [["normal"], ["tangent"], ["uv", "UVMap"]]},{"scene": "Scene", "uv_multiplier": 1.0, "offset_scale": [0.9999999403953552, 0.9999999403953552, 1.0], "materials": ["wood"], "pos": [-3.8710360527038574, -1.7577853202819824, 4.395431041717529], "name": "box.015", "actions": [], "properties": {}, "friction_coefficients": [1.0, 1.0, 1.0], "collision_compound": false, "parent_bone": "", "collision_mask": 255, "linear_factor": [1, 1, 1], "phy_type": "RIGID_BODY", "radius": 1.0, "avg_poly_area": 0.15204958071593533, "color": [1.0, 0.04186555743217468, 0.05154984071850777, 1.0], "dimensions": [1.1936372518539429, 1.193637728691101, 1.1936373710632324], "form_factor": 0.4000000059604645, "elasticity": 0.0, "passes": [0], "stride": 28, "shape_multiplier": 1.0, "mesh_name": "box", "rot": [0.9705750942230225, 0.2255410999059677, -0.06760530918836594, -0.05044485628604889], "no_sleeping": true, "mass": 1.0, "visible": true, "dupli_group": null, "lod_levels": [], "offsets": [0, 0, 672, 132], "zindex": 1, "friction": 0.5, "collision_bounds_type": "BOX", "hash": "896fb455acf4b4e8d4c70694daf5ff068f4cb8d4", "anisotropic_friction": false, "angular_factor": [1, 1, 1], "is_ghost": false, "scale": [1.0925370454788208, 1.0925374031066895, 1.0925372838974], "all_f": false, "parent": null, "type": "MESH", "collision_margin": 0.03999999910593033, "rot_mode": "Q", "collision_group": 1, "elements": [["normal"], ["tangent"], ["uv", "UVMap"]]},{"scene": "Scene", "uv_multiplier": 1.0, "offset_scale": [1.0, 0.9999999403953552, 1.0], "materials": ["wood"], "pos": [-1.478100061416626, 0.924797534942627, 6.571749687194824], "name": "box.014", "actions": [], "properties": {}, "friction_coefficients": [1.0, 1.0, 1.0], "collision_compound": false, "parent_bone": "", "collision_mask": 255, "linear_factor": [1, 1, 1], "phy_type": "RIGID_BODY", "radius": 1.0, "avg_poly_area": 0.15204958071593533, "color": [1.0, 0.30575770139694214, 0.06035693734884262, 1.0], "dimensions": [1.193637728691101, 1.1936376094818115, 1.193637490272522], "form_factor": 0.4000000059604645, "elasticity": 0.0, "passes": [0], "stride": 28, "shape_multiplier": 1.0, "mesh_name": "box", "rot": [0.9004626870155334, -0.29679542779922485, -0.2963232100009918, 0.11520495265722275], "no_sleeping": true, "mass": 1.0, "visible": true, "dupli_group": null, "lod_levels": [], "offsets": [0, 0, 672, 132], "zindex": 1, "friction": 0.5, "collision_bounds_type": "BOX", "hash": "896fb455acf4b4e8d4c70694daf5ff068f4cb8d4", "anisotropic_friction": false, "angular_factor": [1, 1, 1], "is_ghost": false, "scale": [1.092537522315979, 1.0925372838974, 1.0925374031066895], "all_f": false, "parent": null, "type": "MESH", "collision_margin": 0.03999999910593033, "rot_mode": "Q", "collision_group": 1, "elements": [["normal"], ["tangent"], ["uv", "UVMap"]]},{"scene": "Scene", "uv_multiplier": 1.0, "offset_scale": [0.9999999403953552, 1.0, 0.9999999403953552], "materials": ["wood"], "pos": [2.2064154148101807, -3.4319615364074707, 4.419121265411377], "name": "box.013", "actions": [], "properties": {}, "friction_coefficients": [1.0, 1.0, 1.0], "collision_compound": false, "parent_bone": "", "collision_mask": 255, "linear_factor": [1, 1, 1], "phy_type": "RIGID_BODY", "radius": 1.0, "avg_poly_area": 0.15204958071593533, "color": [0.20696669816970825, 0.5174269676208496, 1.0, 1.0], "dimensions": [1.1936373710632324, 1.193637490272522, 1.1936376094818115], "form_factor": 0.4000000059604645, "elasticity": 0.0, "passes": [0], "stride": 28, "shape_multiplier": 1.0, "mesh_name": "box", "rot": [0.9453842043876648, -0.2785828113555908, 0.00894330907613039, 0.16899822652339935], "no_sleeping": true, "mass": 1.0, "visible": true, "dupli_group": null, "lod_levels": [], "offsets": [0, 0, 672, 132], "zindex": 1, "friction": 0.5, "collision_bounds_type": "BOX", "hash": "896fb455acf4b4e8d4c70694daf5ff068f4cb8d4", "anisotropic_friction": false, "angular_factor": [1, 1, 1], "is_ghost": false, "scale": [1.0925371646881104, 1.0925371646881104, 1.092537522315979], "all_f": false, "parent": null, "type": "MESH", "collision_margin": 0.03999999910593033, "rot_mode": "Q", "collision_group": 1, "elements": [["normal"], ["tangent"], ["uv", "UVMap"]]},{"scene": "Scene", "uv_multiplier": 1.0, "offset_scale": [0.9999999403953552, 0.9999998807907104, 0.9999998807907104], "materials": ["wood"], "pos": [-3.850296974182129, 0.3489868640899658, 5.72845983505249], "name": "box.012", "actions": [], "properties": {}, "friction_coefficients": [1.0, 1.0, 1.0], "collision_compound": false, "parent_bone": "", "collision_mask": 255, "linear_factor": [1, 1, 1], "phy_type": "RIGID_BODY", "radius": 1.0, "avg_poly_area": 0.15204958071593533, "color": [1.0, 0.7878773212432861, 0.046919532120227814, 1.0], "dimensions": [1.1936373710632324, 1.193637728691101, 1.1936372518539429], "form_factor": 0.4000000059604645, "elasticity": 0.0, "passes": [0], "stride": 28, "shape_multiplier": 1.0, "mesh_name": "box", "rot": [0.9462177753448486, 0.1754094511270523, 0.22242876887321472, -0.156297504901886], "no_sleeping": true, "mass": 1.0, "visible": true, "dupli_group": null, "lod_levels": [], "offsets": [0, 0, 672, 132], "zindex": 1, "friction": 0.5, "collision_bounds_type": "BOX", "hash": "896fb455acf4b4e8d4c70694daf5ff068f4cb8d4", "anisotropic_friction": false, "angular_factor": [1, 1, 1], "is_ghost": false, "scale": [1.0925371646881104, 1.0925374031066895, 1.0925371646881104], "all_f": false, "parent": null, "type": "MESH", "collision_margin": 0.03999999910593033, "rot_mode": "Q", "collision_group": 1, "elements": [["normal"], ["tangent"], ["uv", "UVMap"]]},{"scene": "Scene", "uv_multiplier": 1.0, "offset_scale": [1.0, 1.0000001192092896, 1.0], "materials": ["wood"], "pos": [0.19625836610794067, 0.09745451807975769, 5.50060510635376], "name": "box.010", "actions": [], "properties": {}, "friction_coefficients": [1.0, 1.0, 1.0], "collision_compound": false, "parent_bone": "", "collision_mask": 255, "linear_factor": [1, 1, 1], "phy_type": "RIGID_BODY", "radius": 1.0, "avg_poly_area": 0.15204958071593533, "color": [0.0352468341588974, 0.027979951351881027, 1.0, 1.0], "dimensions": [1.1936373710632324, 1.1936370134353638, 1.1936373710632324], "form_factor": 0.4000000059604645, "elasticity": 0.0, "passes": [0], "stride": 28, "shape_multiplier": 1.0, "mesh_name": "box", "rot": [0.973992645740509, -0.14942407608032227, -0.08321021497249603, -0.1486167460680008], "no_sleeping": true, "mass": 1.0, "visible": true, "dupli_group": null, "lod_levels": [], "offsets": [0, 0, 672, 132], "zindex": 1, "friction": 0.5, "collision_bounds_type": "BOX", "hash": "896fb455acf4b4e8d4c70694daf5ff068f4cb8d4", "anisotropic_friction": false, "angular_factor": [1, 1, 1], "is_ghost": false, "scale": [1.0925371646881104, 1.0925368070602417, 1.0925372838974], "all_f": false, "parent": null, "type": "MESH", "collision_margin": 0.03999999910593033, "rot_mode": "Q", "collision_group": 1, "elements": [["normal"], ["tangent"], ["uv", "UVMap"]]},{"scene": "Scene", "uv_multiplier": 1.0, "offset_scale": [1.0000001192092896, 0.9999999403953552, 1.0], "materials": ["wood"], "pos": [-2.0348405838012695, -1.9659907817840576, 3.257258176803589], "name": "box.009", "actions": [], "properties": {}, "friction_coefficients": [1.0, 1.0, 1.0], "collision_compound": false, "parent_bone": "", "collision_mask": 255, "linear_factor": [1, 1, 1], "phy_type": "RIGID_BODY", "radius": 1.0, "avg_poly_area": 0.15204958071593533, "color": [1.0, 0.03686762601137161, 0.028975268825888634, 1.0], "dimensions": [1.1936372518539429, 1.193637728691101, 1.1936372518539429], "form_factor": 0.4000000059604645, "elasticity": 0.0, "passes": [0], "stride": 28, "shape_multiplier": 1.0, "mesh_name": "box", "rot": [0.9251450896263123, 0.21329592168331146, -0.3049015998840332, 0.07514283061027527], "no_sleeping": true, "mass": 1.0, "visible": true, "dupli_group": null, "lod_levels": [], "offsets": [0, 0, 672, 132], "zindex": 1, "friction": 0.5, "collision_bounds_type": "BOX", "hash": "896fb455acf4b4e8d4c70694daf5ff068f4cb8d4", "anisotropic_friction": false, "angular_factor": [1, 1, 1], "is_ghost": false, "scale": [1.0925371646881104, 1.0925374031066895, 1.0925371646881104], "all_f": false, "parent": null, "type": "MESH", "collision_margin": 0.03999999910593033, "rot_mode": "Q", "collision_group": 1, "elements": [["normal"], ["tangent"], ["uv", "UVMap"]]},{"scene": "Scene", "uv_multiplier": 1.0, "offset_scale": [1.0, 1.0, 1.0], "materials": ["wood"], "pos": [-2.547905683517456, -3.535053253173828, 6.94291353225708], "name": "box.007", "actions": [], "properties": {}, "friction_coefficients": [1.0, 1.0, 1.0], "collision_compound": false, "parent_bone": "", "collision_mask": 255, "linear_factor": [1, 1, 1], "phy_type": "RIGID_BODY", "radius": 1.0, "avg_poly_area": 0.15204958071593533, "color": [1.0, 0.19228991866111755, 0.03390789031982422, 1.0], "dimensions": [1.1936373710632324, 1.193637490272522, 1.1936372518539429], "form_factor": 0.4000000059604645, "elasticity": 0.0, "passes": [0], "stride": 28, "shape_multiplier": 1.0, "mesh_name": "box", "rot": [1.0, 0.0, 0.0, 0.0], "no_sleeping": true, "mass": 1.0, "visible": true, "dupli_group": null, "lod_levels": [], "offsets": [0, 0, 672, 132], "zindex": 1, "friction": 0.5, "collision_bounds_type": "BOX", "hash": "896fb455acf4b4e8d4c70694daf5ff068f4cb8d4", "anisotropic_friction": false, "angular_factor": [1, 1, 1], "is_ghost": false, "scale": [1.0925371646881104, 1.0925371646881104, 1.0925371646881104], "all_f": false, "parent": null, "type": "MESH", "collision_margin": 0.03999999910593033, "rot_mode": "Q", "collision_group": 1, "elements": [["normal"], ["tangent"], ["uv", "UVMap"]]},{"scene": "Scene", "uv_multiplier": 1.0, "offset_scale": [0.9999999403953552, 0.9999998807907104, 1.0], "materials": ["wood"], "pos": [-3.6899495124816895, 0.348987340927124, 2.2409114837646484], "name": "box.008", "actions": [], "properties": {}, "friction_coefficients": [1.0, 1.0, 1.0], "collision_compound": false, "parent_bone": "", "collision_mask": 255, "linear_factor": [1, 1, 1], "phy_type": "RIGID_BODY", "radius": 1.0, "avg_poly_area": 0.15204958071593533, "color": [0.11902099847793579, 0.45980578660964966, 1.0, 1.0], "dimensions": [1.1936368942260742, 1.1936370134353638, 1.1936368942260742], "form_factor": 0.4000000059604645, "elasticity": 0.0, "passes": [0], "stride": 28, "shape_multiplier": 1.0, "mesh_name": "box", "rot": [0.9659219980239868, 0.2521161139011383, 0.05846183001995087, -0.0037863589823246002], "no_sleeping": true, "mass": 1.0, "visible": true, "dupli_group": null, "lod_levels": [], "offsets": [0, 0, 672, 132], "zindex": 1, "friction": 0.5, "collision_bounds_type": "BOX", "hash": "896fb455acf4b4e8d4c70694daf5ff068f4cb8d4", "anisotropic_friction": false, "angular_factor": [1, 1, 1], "is_ghost": false, "scale": [1.0925368070602417, 1.0925368070602417, 1.0925369262695312], "all_f": false, "parent": null, "type": "MESH", "collision_margin": 0.03999999910593033, "rot_mode": "Q", "collision_group": 1, "elements": [["normal"], ["tangent"], ["uv", "UVMap"]]},{"scene": "Scene", "uv_multiplier": 1.0, "offset_scale": [1.0, 1.0, 1.0], "materials": ["wood"], "pos": [-2.0864787101745605, 0.348987340927124, 2.2809979915618896], "name": "box.006", "actions": [], "properties": {}, "friction_coefficients": [1.0, 1.0, 1.0], "collision_compound": false, "parent_bone": "", "collision_mask": 255, "linear_factor": [1, 1, 1], "phy_type": "RIGID_BODY", "radius": 1.0, "avg_poly_area": 0.15204958071593533, "color": [0.13338840007781982, 1.0, 0.4168069064617157, 1.0], "dimensions": [1.1936376094818115, 1.1936376094818115, 1.1936373710632324], "form_factor": 0.4000000059604645, "elasticity": 0.0, "passes": [0], "stride": 28, "shape_multiplier": 1.0, "mesh_name": "box", "rot": [0.9973232746124268, 0.041083432734012604, -0.05872785672545433, 0.01447344571352005], "no_sleeping": true, "mass": 1.0, "visible": true, "dupli_group": null, "lod_levels": [], "offsets": [0, 0, 672, 132], "zindex": 1, "friction": 0.5, "collision_bounds_type": "BOX", "hash": "896fb455acf4b4e8d4c70694daf5ff068f4cb8d4", "anisotropic_friction": false, "angular_factor": [1, 1, 1], "is_ghost": false, "scale": [1.0925374031066895, 1.0925372838974, 1.0925372838974], "all_f": false, "parent": null, "type": "MESH", "collision_margin": 0.03999999910593033, "rot_mode": "Q", "collision_group": 1, "elements": [["normal"], ["tangent"], ["uv", "UVMap"]]},{"scene": "Scene", "uv_multiplier": 1.0, "offset_scale": [1.0, 1.0, 1.0], "materials": ["skin", "cloth", "leather", "metal", "crystal"], "pos": [-0.642379105091095, -5.7846598625183105, -0.041329801082611084], "name": "roorh", "actions": ["simple_action"], "properties": {}, "friction_coefficients": [1.0, 1.0, 1.0], "collision_compound": false, "parent_bone": "", "collision_mask": 255, "linear_factor": [1, 1, 1], "phy_type": "RIGID_BODY", "radius": 1.0, "avg_poly_area": 0.0011860162225770738, "color": [1.0, 1.0, 1.0, 1.0], "dimensions": [2.3873021602630615, 0.9414867162704468, 2.5143043994903564], "form_factor": 0.4000000059604645, "elasticity": 0.0, "passes": [0, 0, 0, 0, 0], "stride": 28, "shape_multiplier": 1.0, "mesh_name": "roorh", "rot": [1.0, 0.0, 0.0, 0.0], "no_sleeping": false, "mass": 1.0, "visible": true, "dupli_group": null, "lod_levels": [{"uv_multiplier": 1.0, "offsets": [0, 0, 490, 297, 6692, 3831, 14175, 7569, 20720, 11034, 21742, 11484], "factor": 0.5, "hash": "f59c63dba1d43428c296c10eb0b4d3799fefa48f", "shape_multiplier": 1.0, "avg_poly_area": 0.002299873575936783}, {"uv_multiplier": 1.0, "offsets": [0, 0, 252, 126, 3864, 1863, 8743, 3858, 12880, 5718, 13503, 5889], "factor": 0.25, "hash": "36baa2b477d9495e8fb383913fa5a4c5c23c0226", "shape_multiplier": 1.0, "avg_poly_area": 0.0043141357725127085}], "offsets": [0, 0, 1274, 864, 11648, 7368, 24388, 14742, 35735, 21858, 37233, 22674], "zindex": 1, "friction": 0.5, "collision_bounds_type": "CONVEX_HULL", "hash": "1458dff2820e33f74daf6cea25d388f96edb8746", "anisotropic_friction": false, "angular_factor": [1, 1, 1], "is_ghost": false, "scale": [1.0, 1.0, 1.0], "all_f": false, "parent": null, "type": "MESH", "collision_margin": 0.03999999910593033, "rot_mode": "Q", "collision_group": 1, "elements": [["normal"], ["tangent"], ["uv", "UVMap"]]},{"scene": "Scene", "uv_multiplier": 1.0, "offset_scale": [1.0, 1.0000001192092896, 1.0], "materials": ["wood"], "pos": [1.9400330781936646, 0.0974549949169159, 2.033100128173828], "name": "box.011", "actions": [], "properties": {}, "friction_coefficients": [1.0, 1.0, 1.0], "collision_compound": false, "parent_bone": "", "collision_mask": 255, "linear_factor": [1, 1, 1], "phy_type": "RIGID_BODY", "radius": 1.0, "avg_poly_area": 0.15204958071593533, "color": [1.0, 0.23812496662139893, 0.8593958020210266, 1.0], "dimensions": [1.193637490272522, 1.193637728691101, 1.1936373710632324], "form_factor": 0.4000000059604645, "elasticity": 0.0, "passes": [0], "stride": 28, "shape_multiplier": 1.0, "mesh_name": "box", "rot": [0.45821407437324524, 0.870288610458374, 0.029911300167441368, 0.17816604673862457], "no_sleeping": true, "mass": 1.0, "visible": true, "dupli_group": null, "lod_levels": [], "offsets": [0, 0, 672, 132], "zindex": 1, "friction": 0.5, "collision_bounds_type": "BOX", "hash": "896fb455acf4b4e8d4c70694daf5ff068f4cb8d4", "anisotropic_friction": false, "angular_factor": [1, 1, 1], "is_ghost": false, "scale": [1.0925372838974, 1.0925374031066895, 1.0925372838974], "all_f": false, "parent": null, "type": "MESH", "collision_margin": 0.03999999910593033, "rot_mode": "Q", "collision_group": 1, "elements": [["normal"], ["tangent"], ["uv", "UVMap"]]},{"scene": "Scene", "uv_multiplier": 1.0, "offset_scale": [1.0, 1.0, 1.0], "materials": ["wood"], "pos": [-0.6462366580963135, -2.4257349967956543, -2.8536577224731445], "name": "floor", "actions": [], "properties": {}, "friction_coefficients": [1.0, 1.0, 1.0], "collision_compound": false, "parent_bone": "", "collision_mask": 255, "linear_factor": [1, 1, 1], "phy_type": "STATIC", "radius": 1.0, "avg_poly_area": 0.3084847529729207, "color": [0.9849011898040771, 1.0, 0.969936192035675, 1.0], "dimensions": [9.966717720031738, 13.552196502685547, 4.240382671356201], "form_factor": 0.4000000059604645, "elasticity": 0.0, "passes": [0], "stride": 28, "shape_multiplier": 1.0, "mesh_name": "wall", "rot": [1.0, 0.0, 0.0, 0.0], "no_sleeping": false, "mass": 1.0, "visible": true, "dupli_group": null, "lod_levels": [], "offsets": [0, 0, 168, 36], "zindex": 1, "friction": 0.5, "collision_bounds_type": "BOX", "hash": "f0ff695a6ccd7bd381652e4499970f76f8c8f779", "anisotropic_friction": false, "angular_factor": [1, 1, 1], "is_ghost": false, "scale": [9.966717720031738, 13.552196502685547, 9.966717720031738], "all_f": false, "parent": null, "type": "MESH", "collision_margin": 0.03999999910593033, "rot_mode": "Q", "collision_group": 2, "elements": [["normal"], ["tangent"], ["uv", "UVMap"]]},{"rot": [0.800736129283905, 0.21104666590690613, 0.07989416271448135, 0.5548855066299438], "clip_end": 30.00200080871582, "scene": "Scene", "lamp_type": "SUN", "offset_scale": [1.0, 1.0, 1.0], "mass": 1.0, "visible": true, "dupli_group": null, "pos": [6.275333881378174, -7.581808567047119, 13.175880432128906], "name": "Lamp", "actions": [], "friction": 0.5, "properties": {}, "rot_mode": "Q", "collision_bounds_type": "BOX", "anisotropic_friction": false, "parent_bone": "", "clip_start": 1.0007989406585693, "shadow": true, "friction_coefficients": [1.0, 1.0, 1.0], "elasticity": 0, "collision_mask": 255, "linear_factor": [1, 1, 1], "falloff_distance": 29.999982833862305, "angular_factor": [1, 1, 1], "is_ghost": false, "scale": [1.0, 1.0, 1.0], "collision_compound": false, "radius": 1.0, "energy": 1, "frustum_size": 10.0, "parent": null, "no_sleeping": false, "color": [2.0, 1.793802261352539, 1.5172812938690186], "collision_margin": 0.05999999865889549, "dimensions": [0.0, 0.0, 0.0], "form_factor": 0.4000000059604645, "phy_type": "STATIC", "collision_group": 1, "type": "LAMP", "tex_size": 256},{"rot": [0.7071067094802856, 0.7071068286895752, 0.0, 0.0], "clip_end": 100.0, "scene": "Scene", "sensor_fit": "AUTO", "offset_scale": [1.0, 1.0000001192092896, 1.0000001192092896], "mass": 1.0, "visible": true, "dupli_group": null, "pos": [-0.5971494317054749, -8.964142799377441, 0.7048674821853638], "name": "Camera", "actions": [], "friction": 0.5, "ortho_scale": 7.314285755157471, "properties": {}, "rot_mode": "Q", "collision_bounds_type": "BOX", "anisotropic_friction": false, "parent_bone": "", "clip_start": 0.10000000149011612, "friction_coefficients": [1.0, 1.0, 1.0], "elasticity": 0, "collision_mask": 255, "linear_factor": [1, 1, 1], "angular_factor": [1, 1, 1], "is_ghost": false, "cam_type": "PERSP", "scale": [1.0, 1.0000001192092896, 1.0000001192092896], "collision_compound": false, "radius": 1.0, "angle": 1.612257719039917, "parent": null, "no_sleeping": false, "color": [0.0, 0.0, 0.0, 0.0], "collision_margin": 0.05999999865889549, "dimensions": [0.0, 0.0, 0.0], "form_factor": 0.4000000059604645, "phy_type": "NO_COLLISION", "collision_group": 1, "type": "CAMERA"},{"code": "#extension GL_OES_standard_derivatives : enable\nprecision highp float;\nprecision highp int;\n\nfloat exp_blender(float f)\n{\n\treturn pow(2.71828182846, f);\n}\n\nfloat compatible_pow(float x, float y)\n{\n\tif(y == 0.0) /* x^0 -> 1, including 0^0 */\n\t\treturn 1.0;\n\n\t/* glsl pow doesn't accept negative x */\n\tif(x < 0.0) {\n\t\tif(mod(-y, 2.0) == 0.0)\n\t\t\treturn pow(-x, y);\n\t\telse\n\t\t\treturn -pow(-x, y);\n\t}\n\telse if(x == 0.0)\n\t\treturn 0.0;\n\n\treturn pow(x, y);\n}\n\nvoid rgb_to_hsv(vec4 rgb, out vec4 outcol)\n{\n\tfloat cmax, cmin, h, s, v, cdelta;\n\tvec3 c;\n\n\tcmax = max(rgb[0], max(rgb[1], rgb[2]));\n\tcmin = min(rgb[0], min(rgb[1], rgb[2]));\n\tcdelta = cmax-cmin;\n\n\tv = cmax;\n\tif (cmax!=0.0)\n\t\ts = cdelta/cmax;\n\telse {\n\t\ts = 0.0;\n\t\th = 0.0;\n\t}\n\n\tif (s == 0.0) {\n\t\th = 0.0;\n\t}\n\telse {\n\t\tc = (vec3(cmax, cmax, cmax) - rgb.xyz)/cdelta;\n\n\t\tif (rgb.x==cmax) h = c[2] - c[1];\n\t\telse if (rgb.y==cmax) h = 2.0 + c[0] -  c[2];\n\t\telse h = 4.0 + c[1] - c[0];\n\n\t\th /= 6.0;\n\n\t\tif (h<0.0)\n\t\t\th += 1.0;\n\t}\n\n\toutcol = vec4(h, s, v, rgb.w);\n}\n\nvoid hsv_to_rgb(vec4 hsv, out vec4 outcol)\n{\n\tfloat i, f, p, q, t, h, s, v;\n\tvec3 rgb;\n\n\th = hsv[0];\n\ts = hsv[1];\n\tv = hsv[2];\n\n\tif(s==0.0) {\n\t\trgb = vec3(v, v, v);\n\t}\n\telse {\n\t\tif(h==1.0)\n\t\t\th = 0.0;\n\t\t\n\t\th *= 6.0;\n\t\ti = floor(h);\n\t\tf = h - i;\n\t\trgb = vec3(f, f, f);\n\t\tp = v*(1.0-s);\n\t\tq = v*(1.0-(s*f));\n\t\tt = v*(1.0-(s*(1.0-f)));\n\t\t\n\t\tif (i == 0.0) rgb = vec3(v, t, p);\n\t\telse if (i == 1.0) rgb = vec3(q, v, p);\n\t\telse if (i == 2.0) rgb = vec3(p, v, t);\n\t\telse if (i == 3.0) rgb = vec3(p, q, v);\n\t\telse if (i == 4.0) rgb = vec3(t, p, v);\n\t\telse rgb = vec3(v, p, q);\n\t}\n\n\toutcol = vec4(rgb, hsv.w);\n}\n\nfloat srgb_to_linearrgb(float c)\n{\n\tif(c < 0.04045)\n\t\treturn (c < 0.0) ? 0.0: c * (1.0 / 12.92);\n\telse\n\t\treturn pow((c + 0.055)*(1.0/1.055), 2.4);\n}\n\nfloat linearrgb_to_srgb(float c)\n{\n\tif(c < 0.0031308)\n\t\treturn (c < 0.0) ? 0.0: c * 12.92;\n\telse\n\t\treturn 1.055 * pow(c, 1.0/2.4) - 0.055;\n}\n\nvoid srgb_to_linearrgb(vec4 col_from, out vec4 col_to)\n{\n\tcol_to.r = srgb_to_linearrgb(col_from.r);\n\tcol_to.g = srgb_to_linearrgb(col_from.g);\n\tcol_to.b = srgb_to_linearrgb(col_from.b);\n\tcol_to.a = col_from.a;\n}\n\nvoid linearrgb_to_srgb(vec4 col_from, out vec4 col_to)\n{\n\tcol_to.r = linearrgb_to_srgb(col_from.r);\n\tcol_to.g = linearrgb_to_srgb(col_from.g);\n\tcol_to.b = linearrgb_to_srgb(col_from.b);\n\tcol_to.a = col_from.a;\n}\n\n#define M_PI 3.14159265358979323846\n#define M_1_PI 0.31830988618379069\n\n/*********** SHADER NODES ***************/\n\nvoid vcol_attribute(vec4 attvcol, out vec4 vcol)\n{\n\tvcol = vec4(attvcol.x/255.0, attvcol.y/255.0, attvcol.z/255.0, 1.0);\n}\n\nvoid uv_attribute(vec2 attuv, out vec3 uv)\n{\n\tuv = vec3(attuv*2.0 - vec2(1.0, 1.0), 0.0);\n}\n\nvoid geom(vec3 co, vec3 nor, mat4 viewinvmat, vec3 attorco, vec2 attuv, vec4 attvcol, out vec3 global, out vec3 local, out vec3 view, out vec3 orco, out vec3 uv, out vec3 normal, out vec4 vcol, out float vcol_alpha, out float frontback)\n{\n\tlocal = co;\n\tview = (0.0 == 0.0)? normalize(local): vec3(0.0, 0.0, -1.0);\n\tglobal = (viewinvmat*vec4(local, 1.0)).xyz;\n\torco = attorco;\n\tuv_attribute(attuv, uv);\n\tnormal = -normalize(nor);\t/* blender render normal is negated */\n\tvcol_attribute(attvcol, vcol);\n\tvcol_alpha = attvcol.a;\n\tfrontback = (gl_FrontFacing)? 1.0: 0.0;\n}\n\nvoid mapping(vec3 vec, mat4 mat, vec3 minvec, vec3 maxvec, float domin, float domax, out vec3 outvec)\n{\n\toutvec = (mat * vec4(vec, 1.0)).xyz;\n\tif(domin == 1.0)\n\t\toutvec = max(outvec, minvec);\n\tif(domax == 1.0)\n\t\toutvec = min(outvec, maxvec);\n}\n\nvoid camera(vec3 co, out vec3 outview, out float outdepth, out float outdist)\n{\n\toutdepth = abs(co.z);\n\toutdist = length(co);\n\toutview = normalize(co);\n}\n\nvoid lamp(vec4 col, vec3 lv, float dist, vec3 shadow, float visifac, out vec4 outcol, out vec3 outlv, out float outdist, out vec4 outshadow, out float outvisifac)\n{\n\toutcol = col;\n\toutlv = lv;\n\toutdist = dist;\n\toutshadow = vec4(shadow, 1.0);\n\toutvisifac = visifac;\n}\n\nvoid math_add(float val1, float val2, out float outval)\n{\n\toutval = val1 + val2;\n}\n\nvoid math_subtract(float val1, float val2, out float outval)\n{\n\toutval = val1 - val2;\n}\n\nvoid math_multiply(float val1, float val2, out float outval)\n{\n\toutval = val1 * val2;\n}\n\nvoid math_divide(float val1, float val2, out float outval)\n{\n\tif (val2 == 0.0)\n\t\toutval = 0.0;\n\telse\n\t\toutval = val1 / val2;\n}\n\nvoid math_sine(float val, out float outval)\n{\n\toutval = sin(val);\n}\n\nvoid math_cosine(float val, out float outval)\n{\n\toutval = cos(val);\n}\n\nvoid math_tangent(float val, out float outval)\n{\n\toutval = tan(val);\n}\n\nvoid math_asin(float val, out float outval)\n{\n\tif (val <= 1.0 && val >= -1.0)\n\t\toutval = asin(val);\n\telse\n\t\toutval = 0.0;\n}\n\nvoid math_acos(float val, out float outval)\n{\n\tif (val <= 1.0 && val >= -1.0)\n\t\toutval = acos(val);\n\telse\n\t\toutval = 0.0;\n}\n\nvoid math_atan(float val, out float outval)\n{\n\toutval = atan(val);\n}\n\nvoid math_pow(float val1, float val2, out float outval)\n{\n\tif (val1 >= 0.0) {\n\t\toutval = compatible_pow(val1, val2);\n\t}\n\telse {\n\t\tfloat val2_mod_1 = mod(abs(val2), 1.0);\n\n\t\tif (val2_mod_1 > 0.999 || val2_mod_1 < 0.001)\n\t\t\toutval = compatible_pow(val1, floor(val2 + 0.5));\n\t\telse\n\t\t\toutval = 0.0;\n\t}\n}\n\nvoid math_log(float val1, float val2, out float outval)\n{\n\tif(val1 > 0.0  && val2 > 0.0)\n\t\toutval= log2(val1) / log2(val2);\n\telse\n\t\toutval= 0.0;\n}\n\nvoid math_max(float val1, float val2, out float outval)\n{\n\toutval = max(val1, val2);\n}\n\nvoid math_min(float val1, float val2, out float outval)\n{\n\toutval = min(val1, val2);\n}\n\nvoid math_round(float val, out float outval)\n{\n\toutval= floor(val + 0.5);\n}\n\nvoid math_less_than(float val1, float val2, out float outval)\n{\n\tif(val1 < val2)\n\t\toutval = 1.0;\n\telse\n\t\toutval = 0.0;\n}\n\nvoid math_greater_than(float val1, float val2, out float outval)\n{\n\tif(val1 > val2)\n\t\toutval = 1.0;\n\telse\n\t\toutval = 0.0;\n}\n\nvoid math_modulo(float val1, float val2, out float outval)\n{\n\tif (val2 == 0.0)\n\t\toutval = 0.0;\n\telse\n\t\toutval = mod(val1, val2);\n}\n\nvoid math_abs(float val1, out float outval)\n{\n    outval = abs(val1);\n}\n\nvoid squeeze(float val, float width, float center, out float outval)\n{\n\toutval = 1.0/(1.0 + pow(2.71828183, -((val-center)*width)));\n}\n\nvoid vec_math_add(vec3 v1, vec3 v2, out vec3 outvec, out float outval)\n{\n\toutvec = v1 + v2;\n\toutval = (abs(outvec[0]) + abs(outvec[1]) + abs(outvec[2]))/3.0;\n}\n\nvoid vec_math_sub(vec3 v1, vec3 v2, out vec3 outvec, out float outval)\n{\n\toutvec = v1 - v2;\n\toutval = (abs(outvec[0]) + abs(outvec[1]) + abs(outvec[2]))/3.0;\n}\n\nvoid vec_math_average(vec3 v1, vec3 v2, out vec3 outvec, out float outval)\n{\n\toutvec = v1 + v2;\n\toutval = length(outvec);\n\toutvec = normalize(outvec);\n}\n\nvoid vec_math_dot(vec3 v1, vec3 v2, out vec3 outvec, out float outval)\n{\n\toutvec = vec3(0, 0, 0);\n\toutval = dot(v1, v2);\n}\n\nvoid vec_math_cross(vec3 v1, vec3 v2, out vec3 outvec, out float outval)\n{\n\toutvec = cross(v1, v2);\n\toutval = length(outvec);\n}\n\nvoid vec_math_normalize(vec3 v, out vec3 outvec, out float outval)\n{\n\toutval = length(v);\n\toutvec = normalize(v);\n}\n\nvoid vec_math_negate(vec3 v, out vec3 outv)\n{\n\toutv = -v;\n}\n\nvoid normal(vec3 dir, vec3 nor, out vec3 outnor, out float outdot)\n{\n\toutnor = nor;\n\toutdot = -dot(dir, nor);\n}\n\nvoid curves_vec(float fac, vec3 vec, sampler2D curvemap, out vec3 outvec)\n{\n\toutvec.x = texture2D(curvemap, vec2((vec.x + 1.0)*0.5, 0.0)).x;\n\toutvec.y = texture2D(curvemap, vec2((vec.y + 1.0)*0.5, 0.0)).y;\n\toutvec.z = texture2D(curvemap, vec2((vec.z + 1.0)*0.5, 0.0)).z;\n\n\tif (fac != 1.0)\n\t\toutvec = (outvec*fac) + (vec*(1.0-fac));\n\n}\n\nvoid curves_rgb(float fac, vec4 col, sampler2D curvemap, out vec4 outcol)\n{\n\toutcol.r = texture2D(curvemap, vec2(texture2D(curvemap, vec2(col.r, 0.0)).a, 0.0)).r;\n\toutcol.g = texture2D(curvemap, vec2(texture2D(curvemap, vec2(col.g, 0.0)).a, 0.0)).g;\n\toutcol.b = texture2D(curvemap, vec2(texture2D(curvemap, vec2(col.b, 0.0)).a, 0.0)).b;\n\n\tif (fac != 1.0)\n\t\toutcol = (outcol*fac) + (col*(1.0-fac));\n\n\toutcol.a = col.a;\n}\n\nvoid set_value(float val, out float outval)\n{\n\toutval = val;\n}\n\nvoid set_rgb(vec3 col, out vec3 outcol)\n{\n\toutcol = col;\n}\n\nvoid set_rgba(vec4 col, out vec4 outcol)\n{\n\toutcol = col;\n}\n\nvoid set_value_zero(out float outval)\n{\n\toutval = 0.0;\n}\n\nvoid set_value_one(out float outval)\n{\n\toutval = 1.0;\n}\n\nvoid set_rgb_zero(out vec3 outval)\n{\n\toutval = vec3(0.0);\n}\n\nvoid set_rgb_one(out vec3 outval)\n{\n\toutval = vec3(1.0);\n}\n\nvoid set_rgba_zero(out vec4 outval)\n{\n\toutval = vec4(0.0);\n}\n\nvoid set_rgba_one(out vec4 outval)\n{\n\toutval = vec4(1.0);\n}\n\nvoid brightness_contrast(vec4 col, float brightness, float contrast, out vec4 outcol)\n{\n\tfloat a = 1.0 + contrast;\n\tfloat b = brightness - contrast*0.5;\n\n\toutcol.r = max(a*col.r + b, 0.0);\n\toutcol.g = max(a*col.g + b, 0.0);\n\toutcol.b = max(a*col.b + b, 0.0);\n\toutcol.a = col.a;\n}\n\nvoid mix_blend(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\toutcol = mix(col1, col2, fac);\n\toutcol.a = col1.a;\n}\n\nvoid mix_add(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\toutcol = mix(col1, col1 + col2, fac);\n\toutcol.a = col1.a;\n}\n\nvoid mix_mult(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\toutcol = mix(col1, col1 * col2, fac);\n\toutcol.a = col1.a;\n}\n\nvoid mix_screen(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\tfloat facm = 1.0 - fac;\n\n\toutcol = vec4(1.0) - (vec4(facm) + fac*(vec4(1.0) - col2))*(vec4(1.0) - col1);\n\toutcol.a = col1.a;\n}\n\nvoid mix_overlay(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\tfloat facm = 1.0 - fac;\n\n\toutcol = col1;\n\n\tif(outcol.r < 0.5)\n\t\toutcol.r *= facm + 2.0*fac*col2.r;\n\telse\n\t\toutcol.r = 1.0 - (facm + 2.0*fac*(1.0 - col2.r))*(1.0 - outcol.r);\n\n\tif(outcol.g < 0.5)\n\t\toutcol.g *= facm + 2.0*fac*col2.g;\n\telse\n\t\toutcol.g = 1.0 - (facm + 2.0*fac*(1.0 - col2.g))*(1.0 - outcol.g);\n\n\tif(outcol.b < 0.5)\n\t\toutcol.b *= facm + 2.0*fac*col2.b;\n\telse\n\t\toutcol.b = 1.0 - (facm + 2.0*fac*(1.0 - col2.b))*(1.0 - outcol.b);\n}\n\nvoid mix_sub(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\toutcol = mix(col1, col1 - col2, fac);\n\toutcol.a = col1.a;\n}\n\nvoid mix_div(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\tfloat facm = 1.0 - fac;\n\n\toutcol = col1;\n\n\tif(col2.r != 0.0) outcol.r = facm*outcol.r + fac*outcol.r/col2.r;\n\tif(col2.g != 0.0) outcol.g = facm*outcol.g + fac*outcol.g/col2.g;\n\tif(col2.b != 0.0) outcol.b = facm*outcol.b + fac*outcol.b/col2.b;\n}\n\nvoid mix_diff(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\toutcol = mix(col1, abs(col1 - col2), fac);\n\toutcol.a = col1.a;\n}\n\nvoid mix_dark(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\toutcol.rgb = min(col1.rgb, col2.rgb*fac);\n\toutcol.a = col1.a;\n}\n\nvoid mix_light(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\toutcol.rgb = max(col1.rgb, col2.rgb*fac);\n\toutcol.a = col1.a;\n}\n\nvoid mix_dodge(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\toutcol = col1;\n\n\tif(outcol.r != 0.0) {\n\t\tfloat tmp = 1.0 - fac*col2.r;\n\t\tif(tmp <= 0.0)\n\t\t\toutcol.r = 1.0;\n\t\telse if((tmp = outcol.r/tmp) > 1.0)\n\t\t\toutcol.r = 1.0;\n\t\telse\n\t\t\toutcol.r = tmp;\n\t}\n\tif(outcol.g != 0.0) {\n\t\tfloat tmp = 1.0 - fac*col2.g;\n\t\tif(tmp <= 0.0)\n\t\t\toutcol.g = 1.0;\n\t\telse if((tmp = outcol.g/tmp) > 1.0)\n\t\t\toutcol.g = 1.0;\n\t\telse\n\t\t\toutcol.g = tmp;\n\t}\n\tif(outcol.b != 0.0) {\n\t\tfloat tmp = 1.0 - fac*col2.b;\n\t\tif(tmp <= 0.0)\n\t\t\toutcol.b = 1.0;\n\t\telse if((tmp = outcol.b/tmp) > 1.0)\n\t\t\toutcol.b = 1.0;\n\t\telse\n\t\t\toutcol.b = tmp;\n\t}\n}\n\nvoid mix_burn(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\tfloat tmp, facm = 1.0 - fac;\n\n\toutcol = col1;\n\n\ttmp = facm + fac*col2.r;\n\tif(tmp <= 0.0)\n\t\toutcol.r = 0.0;\n\telse if((tmp = (1.0 - (1.0 - outcol.r)/tmp)) < 0.0)\n\t\toutcol.r = 0.0;\n\telse if(tmp > 1.0)\n\t\toutcol.r = 1.0;\n\telse\n\t\toutcol.r = tmp;\n\n\ttmp = facm + fac*col2.g;\n\tif(tmp <= 0.0)\n\t\toutcol.g = 0.0;\n\telse if((tmp = (1.0 - (1.0 - outcol.g)/tmp)) < 0.0)\n\t\toutcol.g = 0.0;\n\telse if(tmp > 1.0)\n\t\toutcol.g = 1.0;\n\telse\n\t\toutcol.g = tmp;\n\n\ttmp = facm + fac*col2.b;\n\tif(tmp <= 0.0)\n\t\toutcol.b = 0.0;\n\telse if((tmp = (1.0 - (1.0 - outcol.b)/tmp)) < 0.0)\n\t\toutcol.b = 0.0;\n\telse if(tmp > 1.0)\n\t\toutcol.b = 1.0;\n\telse\n\t\toutcol.b = tmp;\n}\n\nvoid mix_hue(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\tfloat facm = 1.0 - fac;\n\n\toutcol = col1;\n\n\tvec4 hsv, hsv2, tmp;\n\trgb_to_hsv(col2, hsv2);\n\n\tif(hsv2.y != 0.0) {\n\t\trgb_to_hsv(outcol, hsv);\n\t\thsv.x = hsv2.x;\n\t\thsv_to_rgb(hsv, tmp); \n\n\t\toutcol = mix(outcol, tmp, fac);\n\t\toutcol.a = col1.a;\n\t}\n}\n\nvoid mix_sat(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\tfloat facm = 1.0 - fac;\n\n\toutcol = col1;\n\n\tvec4 hsv, hsv2;\n\trgb_to_hsv(outcol, hsv);\n\n\tif(hsv.y != 0.0) {\n\t\trgb_to_hsv(col2, hsv2);\n\n\t\thsv.y = facm*hsv.y + fac*hsv2.y;\n\t\thsv_to_rgb(hsv, outcol);\n\t}\n}\n\nvoid mix_val(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\tfloat facm = 1.0 - fac;\n\n\tvec4 hsv, hsv2;\n\trgb_to_hsv(col1, hsv);\n\trgb_to_hsv(col2, hsv2);\n\n\thsv.z = facm*hsv.z + fac*hsv2.z;\n\thsv_to_rgb(hsv, outcol);\n}\n\nvoid mix_color(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\tfloat facm = 1.0 - fac;\n\n\toutcol = col1;\n\n\tvec4 hsv, hsv2, tmp;\n\trgb_to_hsv(col2, hsv2);\n\n\tif(hsv2.y != 0.0) {\n\t\trgb_to_hsv(outcol, hsv);\n\t\thsv.x = hsv2.x;\n\t\thsv.y = hsv2.y;\n\t\thsv_to_rgb(hsv, tmp); \n\n\t\toutcol = mix(outcol, tmp, fac);\n\t\toutcol.a = col1.a;\n\t}\n}\n\nvoid mix_soft(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\tfloat facm = 1.0 - fac;\n\n\tvec4 one= vec4(1.0);\n\tvec4 scr= one - (one - col2)*(one - col1);\n\toutcol = facm*col1 + fac*((one - col1)*col2*col1 + col1*scr);\n}\n\nvoid mix_linear(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\n\toutcol = col1;\n\n\tif(col2.r > 0.5)\n\t\toutcol.r= col1.r + fac*(2.0*(col2.r - 0.5));\n\telse\n\t\toutcol.r= col1.r + fac*(2.0*(col2.r) - 1.0);\n\n\tif(col2.g > 0.5)\n\t\toutcol.g= col1.g + fac*(2.0*(col2.g - 0.5));\n\telse\n\t\toutcol.g= col1.g + fac*(2.0*(col2.g) - 1.0);\n\n\tif(col2.b > 0.5)\n\t\toutcol.b= col1.b + fac*(2.0*(col2.b - 0.5));\n\telse\n\t\toutcol.b= col1.b + fac*(2.0*(col2.b) - 1.0);\n}\n\nvoid valtorgb(float fac, sampler2D colormap, out vec4 outcol, out float outalpha)\n{\n\toutcol = texture2D(colormap, vec2(fac, 0.0));\n\toutalpha = outcol.a;\n}\n\nvoid rgbtobw(vec4 color, out float outval)  \n{\n\toutval = color.r*0.35 + color.g*0.45 + color.b*0.2; /* keep these factors in sync with texture.h:RGBTOBW */\n}\n\nvoid invert(float fac, vec4 col, out vec4 outcol)\n{\n\toutcol.xyz = mix(col.xyz, vec3(1.0, 1.0, 1.0) - col.xyz, fac);\n\toutcol.w = col.w;\n}\n\nvoid hue_sat(float hue, float sat, float value, float fac, vec4 col, out vec4 outcol)\n{\n\tvec4 hsv;\n\n\trgb_to_hsv(col, hsv);\n\n\thsv[0] += (hue - 0.5);\n\tif(hsv[0]>1.0) hsv[0]-=1.0; else if(hsv[0]<0.0) hsv[0]+= 1.0;\n\thsv[1] *= sat;\n\tif(hsv[1]>1.0) hsv[1]= 1.0; else if(hsv[1]<0.0) hsv[1]= 0.0;\n\thsv[2] *= value;\n\tif(hsv[2]>1.0) hsv[2]= 1.0; else if(hsv[2]<0.0) hsv[2]= 0.0;\n\n\thsv_to_rgb(hsv, outcol);\n\n\toutcol = mix(col, outcol, fac);\n}\n\nvoid separate_rgb(vec4 col, out float r, out float g, out float b)\n{\n\tr = col.r;\n\tg = col.g;\n\tb = col.b;\n}\n\nvoid combine_rgb(float r, float g, float b, out vec4 col)\n{\n\tcol = vec4(r, g, b, 1.0);\n}\n\nvoid separate_hsv(vec4 col, out float h, out float s, out float v)\n{\n\tvec4 hsv;\n\n\trgb_to_hsv(col, hsv);\n\th = hsv[0];\n\ts = hsv[1];\n\tv = hsv[2];\n}\n\nvoid combine_hsv(float h, float s, float v, out vec4 col)\n{\n\thsv_to_rgb(vec4(h, s, v, 1.0), col);\n}\n\nvoid output_node(vec4 rgb, float alpha, out vec4 outrgb)\n{\n\toutrgb = vec4(rgb.rgb, alpha);\n}\n\n/*********** TEXTURES ***************/\n\nvoid texture_flip_blend(vec3 vec, out vec3 outvec)\n{\n\toutvec = vec.yxz;\n}\n\nvoid texture_blend_lin(vec3 vec, out float outval)\n{\n\toutval = (1.0+vec.x)/2.0;\n}\n\nvoid texture_blend_quad(vec3 vec, out float outval)\n{\n\toutval = max((1.0+vec.x)/2.0, 0.0);\n\toutval *= outval;\n}\n\nvoid texture_wood_sin(vec3 vec, out float value, out vec4 color, out vec3 normal)\n{\n\tfloat a = sqrt(vec.x*vec.x + vec.y*vec.y + vec.z*vec.z)*20.0;\n\tfloat wi = 0.5 + 0.5*sin(a);\n\n\tvalue = wi;\n\tcolor = vec4(wi, wi, wi, 1.0);\n\tnormal = vec3(0.0, 0.0, 0.0);\n}\n\nvoid texture_image(vec3 vec, sampler2D ima, out float value, out vec4 color, out vec3 normal)\n{\n\tcolor = texture2D(ima, (vec.xy + vec2(1.0, 1.0))*0.5);\n\tvalue = color.a;\n\n\tnormal.x = 2.0*(color.r - 0.5);\n\tnormal.y = 2.0*(0.5 - color.g);\n\tnormal.z = 2.0*(color.b - 0.5);\n}\n\n/************* MTEX *****************/\n\nvoid texco_orco(vec3 attorco, out vec3 orco)\n{\n\torco = attorco;\n}\n\nvoid texco_uv(vec2 attuv, out vec3 uv)\n{\n\t/* disabled for now, works together with leaving out mtex_2d_mapping\n\t   uv = vec3(attuv*2.0 - vec2(1.0, 1.0), 0.0); */\n\tuv = vec3(attuv, 0.0);\n}\n\nvoid texco_norm(vec3 normal, out vec3 outnormal)\n{\n\t/* corresponds to shi->orn, which is negated so cancels\n\t   out blender normal negation */\n\toutnormal = normalize(normal);\n}\n\nvoid texco_tangent(vec4 tangent, out vec3 outtangent)\n{\n\touttangent = normalize(tangent.xyz);\n}\n\nvoid texco_global(mat4 viewinvmat, vec3 co, out vec3 global)\n{\n\tglobal = (viewinvmat*vec4(co, 1.0)).xyz;\n}\n\nvoid texco_object(mat4 viewinvmat, mat4 obinvmat, vec3 co, out vec3 object)\n{\n\tobject = (obinvmat*(viewinvmat*vec4(co, 1.0))).xyz;\n}\n\nvoid texco_refl(vec3 vn, vec3 view, out vec3 ref)\n{\n\tref = view - 2.0*dot(vn, view)*vn;\n}\n\nvoid shade_norm(vec3 normal, out vec3 outnormal)\n{\n\t/* blender render normal is negated */\n\toutnormal = -normalize(normal);\n}\n\nvoid mtex_rgb_blend(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tfloat facm;\n\n\tfact *= facg;\n\tfacm = 1.0-fact;\n\n\tincol = fact*texcol + facm*outcol;\n}\n\nvoid mtex_rgb_mul(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tfloat facm;\n\n\tfact *= facg;\n\tfacm = 1.0-fact;\n\n\tincol = (facm + fact*texcol)*outcol;\n}\n\nvoid mtex_rgb_screen(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tfloat facm;\n\n\tfact *= facg;\n\tfacm = 1.0-fact;\n\n\tincol = vec3(1.0) - (vec3(facm) + fact*(vec3(1.0) - texcol))*(vec3(1.0) - outcol);\n}\n\nvoid mtex_rgb_overlay(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tfloat facm;\n\n\tfact *= facg;\n\tfacm = 1.0-fact;\n\n\tif(outcol.r < 0.5)\n\t\tincol.r = outcol.r*(facm + 2.0*fact*texcol.r);\n\telse\n\t\tincol.r = 1.0 - (facm + 2.0*fact*(1.0 - texcol.r))*(1.0 - outcol.r);\n\n\tif(outcol.g < 0.5)\n\t\tincol.g = outcol.g*(facm + 2.0*fact*texcol.g);\n\telse\n\t\tincol.g = 1.0 - (facm + 2.0*fact*(1.0 - texcol.g))*(1.0 - outcol.g);\n\n\tif(outcol.b < 0.5)\n\t\tincol.b = outcol.b*(facm + 2.0*fact*texcol.b);\n\telse\n\t\tincol.b = 1.0 - (facm + 2.0*fact*(1.0 - texcol.b))*(1.0 - outcol.b);\n}\n\nvoid mtex_rgb_sub(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tincol = -fact*facg*texcol + outcol;\n}\n\nvoid mtex_rgb_add(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tincol = fact*facg*texcol + outcol;\n}\n\nvoid mtex_rgb_div(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tfloat facm;\n\n\tfact *= facg;\n\tfacm = 1.0-fact;\n\n\tif(texcol.r != 0.0) incol.r = facm*outcol.r + fact*outcol.r/texcol.r;\n\tif(texcol.g != 0.0) incol.g = facm*outcol.g + fact*outcol.g/texcol.g;\n\tif(texcol.b != 0.0) incol.b = facm*outcol.b + fact*outcol.b/texcol.b;\n}\n\nvoid mtex_rgb_diff(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tfloat facm;\n\n\tfact *= facg;\n\tfacm = 1.0-fact;\n\n\tincol = facm*outcol + fact*abs(texcol - outcol);\n}\n\nvoid mtex_rgb_dark(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tfloat facm, col;\n\n\tfact *= facg;\n\tfacm = 1.0-fact;\n\n\tincol.r = min(outcol.r, texcol.r) * fact + outcol.r * facm;\n\tincol.g = min(outcol.g, texcol.g) * fact + outcol.g * facm;\n\tincol.b = min(outcol.b, texcol.b) * fact + outcol.b * facm;\n}\n\nvoid mtex_rgb_light(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tfloat facm, col;\n\n\tfact *= facg;\n\n\tcol = fact*texcol.r;\n\tif(col > outcol.r) incol.r = col; else incol.r = outcol.r;\n\tcol = fact*texcol.g;\n\tif(col > outcol.g) incol.g = col; else incol.g = outcol.g;\n\tcol = fact*texcol.b;\n\tif(col > outcol.b) incol.b = col; else incol.b = outcol.b;\n}\n\nvoid mtex_rgb_hue(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tvec4 col;\n\n\tmix_hue(fact*facg, vec4(outcol, 1.0), vec4(texcol, 1.0), col);\n\tincol.rgb = col.rgb;\n}\n\nvoid mtex_rgb_sat(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tvec4 col;\n\n\tmix_sat(fact*facg, vec4(outcol, 1.0), vec4(texcol, 1.0), col);\n\tincol.rgb = col.rgb;\n}\n\nvoid mtex_rgb_val(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tvec4 col;\n\n\tmix_val(fact*facg, vec4(outcol, 1.0), vec4(texcol, 1.0), col);\n\tincol.rgb = col.rgb;\n}\n\nvoid mtex_rgb_color(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tvec4 col;\n\n\tmix_color(fact*facg, vec4(outcol, 1.0), vec4(texcol, 1.0), col);\n\tincol.rgb = col.rgb;\n}\n\nvoid mtex_value_vars(inout float fact, float facg, out float facm)\n{\n\tfact *= abs(facg);\n\tfacm = 1.0-fact;\n\n\tif(facg < 0.0) {\n\t\tfloat tmp = fact;\n\t\tfact = facm;\n\t\tfacm = tmp;\n\t}\n}\n\nvoid mtex_value_blend(float outcol, float texcol, float fact, float facg, out float incol)\n{\n\tfloat facm;\n\tmtex_value_vars(fact, facg, facm);\n\n\tincol = fact*texcol + facm*outcol;\n}\n\nvoid mtex_value_mul(float outcol, float texcol, float fact, float facg, out float incol)\n{\n\tfloat facm;\n\tmtex_value_vars(fact, facg, facm);\n\n\tfacm = 1.0 - facg;\n\tincol = (facm + fact*texcol)*outcol;\n}\n\nvoid mtex_value_screen(float outcol, float texcol, float fact, float facg, out float incol)\n{\n\tfloat facm;\n\tmtex_value_vars(fact, facg, facm);\n\n\tfacm = 1.0 - facg;\n\tincol = 1.0 - (facm + fact*(1.0 - texcol))*(1.0 - outcol);\n}\n\nvoid mtex_value_sub(float outcol, float texcol, float fact, float facg, out float incol)\n{\n\tfloat facm;\n\tmtex_value_vars(fact, facg, facm);\n\n\tfact = -fact;\n\tincol = fact*texcol + outcol;\n}\n\nvoid mtex_value_add(float outcol, float texcol, float fact, float facg, out float incol)\n{\n\tfloat facm;\n\tmtex_value_vars(fact, facg, facm);\n\n\tfact = fact;\n\tincol = fact*texcol + outcol;\n}\n\nvoid mtex_value_div(float outcol, float texcol, float fact, float facg, out float incol)\n{\n\tfloat facm;\n\tmtex_value_vars(fact, facg, facm);\n\n\tif(texcol != 0.0)\n\t\tincol = facm*outcol + fact*outcol/texcol;\n\telse\n\t\tincol = 0.0;\n}\n\nvoid mtex_value_diff(float outcol, float texcol, float fact, float facg, out float incol)\n{\n\tfloat facm;\n\tmtex_value_vars(fact, facg, facm);\n\n\tincol = facm*outcol + fact*abs(texcol - outcol);\n}\n\nvoid mtex_value_dark(float outcol, float texcol, float fact, float facg, out float incol)\n{\n\tfloat facm;\n\tmtex_value_vars(fact, facg, facm);\n\n\tincol = facm*outcol + fact*min(outcol, texcol);\n}\n\nvoid mtex_value_light(float outcol, float texcol, float fact, float facg, out float incol)\n{\n\tfloat facm;\n\tmtex_value_vars(fact, facg, facm);\n\n\tfloat col = fact*texcol;\n\tif(col > outcol) incol = col; else incol = outcol;\n}\n\nvoid mtex_value_clamp_positive(float fac, out float outfac)\n{\n\toutfac = max(fac, 0.0);\n}\n\nvoid mtex_value_clamp(float fac, out float outfac)\n{\n\toutfac = clamp(fac, 0.0, 1.0);\n}\n\nvoid mtex_har_divide(float har, out float outhar)\n{\n\touthar = har/128.0;\n}\n\nvoid mtex_har_multiply_clamp(float har, out float outhar)\n{\n\thar *= 128.0;\n\n\tif(har < 1.0) outhar = 1.0;\n\telse if(har > 511.0) outhar = 511.0;\n\telse outhar = har;\n}\n\nvoid mtex_alpha_from_col(vec4 col, out float alpha)\n{\n\talpha = col.a;\n}\n\nvoid mtex_alpha_to_col(vec4 col, float alpha, out vec4 outcol)\n{\n\toutcol = vec4(col.rgb, alpha);\n}\n\nvoid mtex_rgbtoint(vec4 rgb, out float intensity)\n{\n\tintensity = dot(vec3(0.35, 0.45, 0.2), rgb.rgb);\n}\n\nvoid mtex_value_invert(float invalue, out float outvalue)\n{\n\toutvalue = 1.0 - invalue;\n}\n\nvoid mtex_rgb_invert(vec4 inrgb, out vec4 outrgb)\n{\n\toutrgb = vec4(vec3(1.0) - inrgb.rgb, inrgb.a);\n}\n\nvoid mtex_value_stencil(float stencil, float intensity, out float outstencil, out float outintensity)\n{\n\tfloat fact = intensity;\n\toutintensity = intensity*stencil;\n\toutstencil = stencil*fact;\n}\n\nvoid mtex_rgb_stencil(float stencil, vec4 rgb, out float outstencil, out vec4 outrgb)\n{\n\tfloat fact = rgb.a;\n\toutrgb = vec4(rgb.rgb, rgb.a*stencil);\n\toutstencil = stencil*fact;\n}\n\nvoid mtex_mapping_ofs(vec3 texco, vec3 ofs, out vec3 outtexco)\n{\n\touttexco = texco + ofs;\n}\n\nvoid mtex_mapping_size(vec3 texco, vec3 size, out vec3 outtexco)\n{\n\touttexco = size*texco;\n}\n\nvoid mtex_2d_mapping(vec3 vec, out vec3 outvec)\n{\n\toutvec = vec3(vec.xy*0.5 + vec2(0.5, 0.5), vec.z);\n}\n\nvoid mtex_image(vec3 texco, sampler2D ima, out float value, out vec4 color)\n{\n\tcolor = texture2D(ima, texco.xy);\n\tvalue = 1.0;\n}\n\nvoid mtex_normal(vec3 texco, sampler2D ima, out vec3 normal)\n{\n\t// The invert of the red channel is to make\n\t// the normal map compliant with the outside world.\n\t// It needs to be done because in Blender\n\t// the normal used points inward.\n\t// Should this ever change this negate must be removed.\n\tvec4 color = texture2D(ima, texco.xy);\n\tnormal = 2.0*(vec3(-color.r, color.g, color.b) - vec3(-0.5, 0.5, 0.5));\n}\n\nvoid mtex_bump_normals_init( vec3 vN, out vec3 vNorg, out vec3 vNacc, out float fPrevMagnitude )\n{\n\tvNorg = vN;\n\tvNacc = vN;\n\tfPrevMagnitude = 1.0;\n}\n\n/** helper method to extract the upper left 3x3 matrix from a 4x4 matrix */\nmat3 to_mat3(mat4 m4)\n{\n\tmat3 m3;\n\tm3[0] = m4[0].xyz;\n\tm3[1] = m4[1].xyz;\n\tm3[2] = m4[2].xyz;\n\treturn m3;\n}\n\nvoid mtex_bump_init_objspace( vec3 surf_pos, vec3 surf_norm,\n\t\t\t\t\t\t\t  mat4 mView, mat4 mViewInv, mat4 mObj, mat4 mObjInv, \n\t\t\t\t\t\t\t  float fPrevMagnitude_in, vec3 vNacc_in,\n\t\t\t\t\t\t\t  out float fPrevMagnitude_out, out vec3 vNacc_out, \n\t\t\t\t\t\t\t  out vec3 vR1, out vec3 vR2, out float fDet ) \n{\n\tmat3 obj2view = to_mat3(mat4(1));\n\tmat3 view2obj = to_mat3(mat4(1));\n\t\n\tvec3 vSigmaS = view2obj * dFdx( surf_pos );\n\tvec3 vSigmaT = view2obj * dFdy( surf_pos );\n\tvec3 vN = normalize( surf_norm * obj2view );\n\n\tvR1 = cross( vSigmaT, vN );\n\tvR2 = cross( vN, vSigmaS ) ;\n\tfDet = dot ( vSigmaS, vR1 );\n\t\n\t/* pretransform vNacc (in mtex_bump_apply) using the inverse transposed */\n\tvR1 = vR1 * view2obj;\n\tvR2 = vR2 * view2obj;\n\tvN = vN * view2obj;\n\t\n\tfloat fMagnitude = abs(fDet) * length(vN);\n\tvNacc_out = vNacc_in * (fMagnitude / fPrevMagnitude_in);\n\tfPrevMagnitude_out = fMagnitude;\n}\n\nvoid mtex_bump_init_texturespace( vec3 surf_pos, vec3 surf_norm, \n\t\t\t\t\t\t\t\t  float fPrevMagnitude_in, vec3 vNacc_in,\n\t\t\t\t\t\t\t\t  out float fPrevMagnitude_out, out vec3 vNacc_out, \n\t\t\t\t\t\t\t\t  out vec3 vR1, out vec3 vR2, out float fDet ) \n{\n\tvec3 vSigmaS = dFdx( surf_pos );\n\tvec3 vSigmaT = dFdy( surf_pos );\n\tvec3 vN = surf_norm; /* normalized interpolated vertex normal */\n\t\n\tvR1 = normalize( cross( vSigmaT, vN ) );\n\tvR2 = normalize( cross( vN, vSigmaS ) );\n\tfDet = sign( dot(vSigmaS, vR1) );\n\t\n\tfloat fMagnitude = abs(fDet);\n\tvNacc_out = vNacc_in * (fMagnitude / fPrevMagnitude_in);\n\tfPrevMagnitude_out = fMagnitude;\n}\n\nvoid mtex_bump_init_viewspace( vec3 surf_pos, vec3 surf_norm, \n\t\t\t\t\t\t\t   float fPrevMagnitude_in, vec3 vNacc_in,\n\t\t\t\t\t\t\t   out float fPrevMagnitude_out, out vec3 vNacc_out, \n\t\t\t\t\t\t\t   out vec3 vR1, out vec3 vR2, out float fDet ) \n{\n\tvec3 vSigmaS = dFdx( surf_pos );\n\tvec3 vSigmaT = dFdy( surf_pos );\n\tvec3 vN = surf_norm; /* normalized interpolated vertex normal */\n\t\n\tvR1 = cross( vSigmaT, vN );\n\tvR2 = cross( vN, vSigmaS ) ;\n\tfDet = dot ( vSigmaS, vR1 );\n\t\n\tfloat fMagnitude = abs(fDet);\n\tvNacc_out = vNacc_in * (fMagnitude / fPrevMagnitude_in);\n\tfPrevMagnitude_out = fMagnitude;\n}\n\nvoid mtex_bump_tap3( vec3 texco, sampler2D ima, float hScale, \n                     out float dBs, out float dBt )\n{\n\tvec2 STll = texco.xy;\n\tvec2 STlr = texco.xy + dFdx(texco.xy) ;\n\tvec2 STul = texco.xy + dFdy(texco.xy) ;\n\t\n\tfloat Hll,Hlr,Hul;\n\trgbtobw( texture2D(ima, STll), Hll );\n\trgbtobw( texture2D(ima, STlr), Hlr );\n\trgbtobw( texture2D(ima, STul), Hul );\n\t\n\tdBs = hScale * (Hlr - Hll);\n\tdBt = hScale * (Hul - Hll);\n}\n\n#ifdef BUMP_BICUBIC\n\nvoid mtex_bump_bicubic( vec3 texco, sampler2D ima, float hScale, \n                     out float dBs, out float dBt ) \n{\n\tfloat Hl;\n\tfloat Hr;\n\tfloat Hd;\n\tfloat Hu;\n\t\n\tvec2 TexDx = dFdx(texco.xy);\n\tvec2 TexDy = dFdy(texco.xy);\n \n\tvec2 STl = texco.xy - 0.5 * TexDx ;\n\tvec2 STr = texco.xy + 0.5 * TexDx ;\n\tvec2 STd = texco.xy - 0.5 * TexDy ;\n\tvec2 STu = texco.xy + 0.5 * TexDy ;\n\t\n\trgbtobw(texture2D(ima, STl), Hl);\n\trgbtobw(texture2D(ima, STr), Hr);\n\trgbtobw(texture2D(ima, STd), Hd);\n\trgbtobw(texture2D(ima, STu), Hu);\n\t\n\tvec2 dHdxy = vec2(Hr - Hl, Hu - Hd);\n\tfloat fBlend = clamp(1.0-textureQueryLOD(ima, texco.xy).x, 0.0, 1.0);\n\tif(fBlend!=0.0)\n\t{\n\t\t// the derivative of the bicubic sampling of level 0\n\t\tivec2 vDim;\n\t\tvDim = textureSize(ima, 0);\n\n\t\t// taking the fract part of the texture coordinate is a hardcoded wrap mode.\n\t\t// this is acceptable as textures use wrap mode exclusively in 3D view elsewhere in blender. \n\t\t// this is done so that we can still get a valid texel with uvs outside the 0,1 range\n\t\t// by texelFetch below, as coordinates are clamped when using this function.\n\t\tvec2 fTexLoc = vDim*fract(texco.xy) - vec2(0.5, 0.5);\n\t\tivec2 iTexLoc = ivec2(floor(fTexLoc));\n\t\tvec2 t = clamp(fTexLoc - iTexLoc, 0.0, 1.0);\t\t// sat just to be pedantic\n\n/*******************************************************************************************\n * This block will replace the one below when one channel textures are properly supported. *\n *******************************************************************************************\n\t\tvec4 vSamplesUL = textureGather(ima, (iTexLoc+ivec2(-1,-1) + vec2(0.5,0.5))/vDim );\n\t\tvec4 vSamplesUR = textureGather(ima, (iTexLoc+ivec2(1,-1) + vec2(0.5,0.5))/vDim );\n\t\tvec4 vSamplesLL = textureGather(ima, (iTexLoc+ivec2(-1,1) + vec2(0.5,0.5))/vDim );\n\t\tvec4 vSamplesLR = textureGather(ima, (iTexLoc+ivec2(1,1) + vec2(0.5,0.5))/vDim );\n\n\t\tmat4 H = mat4(vSamplesUL.w, vSamplesUL.x, vSamplesLL.w, vSamplesLL.x,\n\t\t\t\t\tvSamplesUL.z, vSamplesUL.y, vSamplesLL.z, vSamplesLL.y,\n\t\t\t\t\tvSamplesUR.w, vSamplesUR.x, vSamplesLR.w, vSamplesLR.x,\n\t\t\t\t\tvSamplesUR.z, vSamplesUR.y, vSamplesLR.z, vSamplesLR.y);\n*/\t\n\t\tivec2 iTexLocMod = iTexLoc + ivec2(-1, -1);\n\n\t\tmat4 H;\n\t\t\n\t\tfor(int i = 0; i < 4; i++) {\n\t\t\tfor(int j = 0; j < 4; j++) {\n\t\t\t\tivec2 iTexTmp = iTexLocMod + ivec2(i,j);\n\t\t\t\t\n\t\t\t\t// wrap texture coordinates manually for texelFetch to work on uvs oitside the 0,1 range.\n\t\t\t\t// this is guaranteed to work since we take the fractional part of the uv above.\n\t\t\t\tiTexTmp.x = (iTexTmp.x < 0)? iTexTmp.x + vDim.x : ((iTexTmp.x >= vDim.x)? iTexTmp.x - vDim.x : iTexTmp.x);\n\t\t\t\tiTexTmp.y = (iTexTmp.y < 0)? iTexTmp.y + vDim.y : ((iTexTmp.y >= vDim.y)? iTexTmp.y - vDim.y : iTexTmp.y);\n\n\t\t\t\trgbtobw(texelFetch(ima, iTexTmp, 0), H[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfloat x = t.x, y = t.y;\n\t\tfloat x2 = x * x, x3 = x2 * x, y2 = y * y, y3 = y2 * y;\n\n\t\tvec4 X = vec4(-0.5*(x3+x)+x2,\t\t1.5*x3-2.5*x2+1,\t-1.5*x3+2*x2+0.5*x,\t\t0.5*(x3-x2));\n\t\tvec4 Y = vec4(-0.5*(y3+y)+y2,\t\t1.5*y3-2.5*y2+1,\t-1.5*y3+2*y2+0.5*y,\t\t0.5*(y3-y2));\n\t\tvec4 dX = vec4(-1.5*x2+2*x-0.5,\t\t4.5*x2-5*x,\t\t\t-4.5*x2+4*x+0.5,\t\t1.5*x2-x);\n\t\tvec4 dY = vec4(-1.5*y2+2*y-0.5,\t\t4.5*y2-5*y,\t\t\t-4.5*y2+4*y+0.5,\t\t1.5*y2-y);\n\t\n\t\t// complete derivative in normalized coordinates (mul by vDim)\n\t\tvec2 dHdST = vDim * vec2(dot(Y, H * dX), dot(dY, H * X));\n\n\t\t// transform derivative to screen-space\n\t\tvec2 dHdxy_bicubic = vec2( dHdST.x * TexDx.x + dHdST.y * TexDx.y,\n\t\t\t\t\t\t\t\t   dHdST.x * TexDy.x + dHdST.y * TexDy.y );\n\n\t\t// blend between the two\n\t\tdHdxy = dHdxy*(1-fBlend) + dHdxy_bicubic*fBlend;\n\t}\n\n\tdBs = hScale * dHdxy.x;\n\tdBt = hScale * dHdxy.y;\n}\n\n#endif\n\nvoid mtex_bump_tap5( vec3 texco, sampler2D ima, float hScale, \n                     out float dBs, out float dBt ) \n{\n\tvec2 TexDx = dFdx(texco.xy);\n\tvec2 TexDy = dFdy(texco.xy);\n\n\tvec2 STc = texco.xy;\n\tvec2 STl = texco.xy - 0.5 * TexDx ;\n\tvec2 STr = texco.xy + 0.5 * TexDx ;\n\tvec2 STd = texco.xy - 0.5 * TexDy ;\n\tvec2 STu = texco.xy + 0.5 * TexDy ;\n\t\n\tfloat Hc,Hl,Hr,Hd,Hu;\n\trgbtobw( texture2D(ima, STc), Hc );\n\trgbtobw( texture2D(ima, STl), Hl );\n\trgbtobw( texture2D(ima, STr), Hr );\n\trgbtobw( texture2D(ima, STd), Hd );\n\trgbtobw( texture2D(ima, STu), Hu );\n\t\n\tdBs = hScale * (Hr - Hl);\n\tdBt = hScale * (Hu - Hd);\n}\n\nvoid mtex_bump_deriv( vec3 texco, sampler2D ima, float ima_x, float ima_y, float hScale, \n                     out float dBs, out float dBt ) \n{\n\tfloat s = 1.0;\t\t// negate this if flipped texture coordinate\n\tvec2 TexDx = dFdx(texco.xy);\n\tvec2 TexDy = dFdy(texco.xy);\n\t\n\t// this variant using a derivative map is described here\n\t// http://mmikkelsen3d.blogspot.com/2011/07/derivative-maps.html\n\tvec2 dim = vec2(ima_x, ima_y);\n\tvec2 dBduv = hScale*dim*(2.0*texture2D(ima, texco.xy).xy-1.0);\n\t\n\tdBs = dBduv.x*TexDx.x + s*dBduv.y*TexDx.y;\n\tdBt = dBduv.x*TexDy.x + s*dBduv.y*TexDy.y;\n}\n\nvoid mtex_bump_apply( float fDet, float dBs, float dBt, vec3 vR1, vec3 vR2, vec3 vNacc_in,\n\t\t\t\t\t  out vec3 vNacc_out, out vec3 perturbed_norm ) \n{\n\tvec3 vSurfGrad = sign(fDet) * ( dBs * vR1 + dBt * vR2 );\n\t\n\tvNacc_out = vNacc_in - vSurfGrad;\n\tperturbed_norm = normalize( vNacc_out );\n}\n\nvoid mtex_bump_apply_texspace( float fDet, float dBs, float dBt, vec3 vR1, vec3 vR2,\n                               sampler2D ima, vec3 texco, float ima_x, float ima_y, vec3 vNacc_in,\n\t\t\t\t\t\t\t   out vec3 vNacc_out, out vec3 perturbed_norm ) \n{\n\tvec2 TexDx = dFdx(texco.xy);\n\tvec2 TexDy = dFdy(texco.xy);\n\n\tvec3 vSurfGrad = sign(fDet) * ( \n\t            dBs / length( vec2(ima_x*TexDx.x, ima_y*TexDx.y) ) * vR1 + \n\t            dBt / length( vec2(ima_x*TexDy.x, ima_y*TexDy.y) ) * vR2 );\n\t\t\t\t\n\tvNacc_out = vNacc_in - vSurfGrad;\n\tperturbed_norm = normalize( vNacc_out );\n}\n\nvoid mtex_negate_texnormal(vec3 normal, out vec3 outnormal)\n{\n\toutnormal = vec3(-normal.x, -normal.y, normal.z);\n}\n\nvoid mtex_nspace_tangent(vec4 tangent, vec3 normal, vec3 texnormal, out vec3 outnormal)\n{\n\tvec3 B = tangent.w * cross(normal, tangent.xyz);\n\n\toutnormal = texnormal.x*tangent.xyz + texnormal.y*B + texnormal.z*normal;\n\toutnormal = normalize(outnormal);\n}\n\nvoid mtex_nspace_world(mat4 viewmat, vec3 texnormal, out vec3 outnormal)\n{\n\toutnormal = normalize((viewmat*vec4(texnormal, 0.0)).xyz);\n}\n\nvoid mtex_nspace_object(mat4 viewmat, mat4 obmat, vec3 texnormal, out vec3 outnormal)\n{\n\toutnormal = normalize((viewmat*(obmat*vec4(texnormal, 0.0))).xyz);\n}\n\nvoid mtex_blend_normal(float norfac, vec3 normal, vec3 newnormal, out vec3 outnormal)\n{\n\toutnormal = (1.0 - norfac)*normal + norfac*newnormal;\n\toutnormal = normalize(outnormal);\n}\n\n/******* MATERIAL *********/\n\nvoid lamp_visibility_sun_hemi(vec3 lampvec, out vec3 lv, out float dist, out float visifac)\n{\n\tlv = lampvec;\n\tdist = 1.0;\n\tvisifac = 1.0;\n}\n\nvoid lamp_visibility_other(vec3 co, vec3 lampco, out vec3 lv, out float dist, out float visifac)\n{\n\tlv = co - lampco;\n\tdist = length(lv);\n\tlv = normalize(lv);\n\tvisifac = 1.0;\n}\n\nvoid lamp_falloff_invlinear(float lampdist, float dist, out float visifac)\n{\n\tvisifac = lampdist/(lampdist + dist);\n}\n\nvoid lamp_falloff_invsquare(float lampdist, float dist, out float visifac)\n{\n\tvisifac = lampdist/(lampdist + dist*dist);\n}\n\nvoid lamp_falloff_sliders(float lampdist, float ld1, float ld2, float dist, out float visifac)\n{\n\tfloat lampdistkw = lampdist*lampdist;\n\n\tvisifac = lampdist/(lampdist + ld1*dist);\n\tvisifac *= lampdistkw/(lampdistkw + ld2*dist*dist);\n}\n\nvoid lamp_falloff_curve(float lampdist, sampler2D curvemap, float dist, out float visifac)\n{\n\tvisifac = texture2D(curvemap, vec2(dist/lampdist, 0.0)).x;\n}\n\nvoid lamp_visibility_sphere(float lampdist, float dist, float visifac, out float outvisifac)\n{\n\tfloat t= lampdist - dist;\n\n\toutvisifac= visifac*max(t, 0.0)/lampdist;\n}\n\nvoid lamp_visibility_spot_square(vec3 lampvec, mat4 lampimat, vec3 lv, out float inpr)\n{\n\tif(dot(lv, lampvec) > 0.0) {\n\t\tvec3 lvrot = (lampimat*vec4(lv, 0.0)).xyz;\n\t\tfloat x = max(abs(lvrot.x/lvrot.z), abs(lvrot.y/lvrot.z));\n\n\t\tinpr = 1.0/sqrt(1.0 + x*x);\n\t}\n\telse\n\t\tinpr = 0.0;\n}\n\nvoid lamp_visibility_spot_circle(vec3 lampvec, vec3 lv, out float inpr)\n{\n\tinpr = dot(lv, lampvec);\n}\n\nvoid lamp_visibility_spot(float spotsi, float spotbl, float inpr, float visifac, out float outvisifac)\n{\n\tfloat t = spotsi;\n\n\tif(inpr <= t) {\n\t\toutvisifac = 0.0;\n\t}\n\telse {\n\t\tt = inpr - t;\n\n\t\t/* soft area */\n\t\tif(spotbl != 0.0)\n\t\t\tinpr *= smoothstep(0.0, 1.0, t/spotbl);\n\n\t\toutvisifac = visifac*inpr;\n\t}\n}\n\nvoid lamp_visibility_clamp(float visifac, out float outvisifac)\n{\n\toutvisifac = (visifac < 0.001)? 0.0: visifac;\n}\n\nvoid shade_view(vec3 co, out vec3 view)\n{\n\t/* handle perspective/orthographic */\n\tview = (0.0 == 0.0)? normalize(co): vec3(0.0, 0.0, -1.0);\n}\n\nvoid shade_tangent_v(vec3 lv, vec3 tang, out vec3 vn)\n{\n\tvec3 c = cross(lv, tang);\n\tvec3 vnor = cross(c, tang);\n\n\tvn = -normalize(vnor);\n}\n\nvoid shade_inp(vec3 vn, vec3 lv, out float inp)\n{\n\tinp = dot(vn, lv);\n}\n\nvoid shade_is_no_diffuse(out float is)\n{\n\tis = 0.0;\n}\n\nvoid shade_is_hemi(float inp, out float is)\n{\n\tis = 0.5*inp + 0.5;\n}\n\nfloat area_lamp_energy(mat4 area, vec3 co, vec3 vn)\n{\n\tvec3 vec[4], c[4];\n\tfloat rad[4];float fac;\n\t\n\tvec[0] = normalize(co - area[0].xyz);\n\tvec[1] = normalize(co - area[1].xyz);\n\tvec[2] = normalize(co - area[2].xyz);\n\tvec[3] = normalize(co - area[3].xyz);\n\n\tc[0] = normalize(cross(vec[0], vec[1]));\n\tc[1] = normalize(cross(vec[1], vec[2]));\n\tc[2] = normalize(cross(vec[2], vec[3]));\n\tc[3] = normalize(cross(vec[3], vec[0]));\n\n\trad[0] = acos(dot(vec[0], vec[1]));\n\trad[1] = acos(dot(vec[1], vec[2]));\n\trad[2] = acos(dot(vec[2], vec[3]));\n\trad[3] = acos(dot(vec[3], vec[0]));\n\n\tfac=  rad[0]*dot(vn, c[0]);\n\tfac+= rad[1]*dot(vn, c[1]);\n\tfac+= rad[2]*dot(vn, c[2]);\n\tfac+= rad[3]*dot(vn, c[3]);\n\n\treturn max(fac, 0.0);\n}\n\nvoid shade_inp_area(vec3 position, vec3 lampco, vec3 lampvec, vec3 vn, mat4 area, float areasize, float k, out float inp)\n{\n\tvec3 co = position;\n\tvec3 vec = co - lampco;\n\n\tif(dot(vec, lampvec) < 0.0) {\n\t\tinp = 0.0;\n\t}\n\telse {\n\t\tfloat intens = area_lamp_energy(area, co, vn);\n\n\t\tinp = pow(intens*areasize, k);\n\t}\n}\n\nvoid shade_diffuse_oren_nayer(float nl, vec3 n, vec3 l, vec3 v, float rough, out float is)\n{\n\tvec3 h = normalize(v + l);\n\tfloat nh = max(dot(n, h), 0.0);\n\tfloat nv = max(dot(n, v), 0.0);\n\tfloat realnl = dot(n, l);\n\n\tif(realnl < 0.0) {\n\t\tis = 0.0;\n\t}\n\telse if(nl < 0.0) {\n\t\tis = 0.0;\n\t}\n\telse {\n\t\tfloat vh = max(dot(v, h), 0.0);\n\t\tfloat Lit_A = acos(realnl);\n\t\tfloat View_A = acos(nv);\n\n\t\tvec3 Lit_B = normalize(l - realnl*n);\n\t\tvec3 View_B = normalize(v - nv*n);\n\n\t\tfloat t = max(dot(Lit_B, View_B), 0.0);\n\n\t\tfloat a, b;\n\n\t\tif(Lit_A > View_A) {\n\t\t\ta = Lit_A;\n\t\t\tb = View_A;\n\t\t}\n\t\telse {\n\t\t\ta = View_A;\n\t\t\tb = Lit_A;\n\t\t}\n\n\t\tfloat A = 1.0 - (0.5*((rough*rough)/((rough*rough) + 0.33)));\n\t\tfloat B = 0.45*((rough*rough)/((rough*rough) + 0.09));\n\n\t\tb *= 0.95;\n\t\tis = nl*(A + (B * t * sin(a) * tan(b)));\n\t}\n}\n\nvoid shade_diffuse_toon(vec3 n, vec3 l, vec3 v, float size, float tsmooth, out float is)\n{\n\tfloat rslt = dot(n, l);\n\tfloat ang = acos(rslt);\n\n\tif(ang < size) is = 1.0;\n\telse if(ang > (size + tsmooth) || tsmooth == 0.0) is = 0.0;\n\telse is = 1.0 - ((ang - size)/tsmooth);\n}\n\nvoid shade_diffuse_minnaert(float nl, vec3 n, vec3 v, float darkness, out float is)\n{\n\tif(nl <= 0.0) {\n\t\tis = 0.0;\n\t}\n\telse {\n\t\tfloat nv = max(dot(n, v), 0.0);\n\n\t\tif(darkness <= 1.0)\n\t\t\tis = nl*pow(max(nv*nl, 0.1), darkness - 1.0);\n\t\telse\n\t\t\tis = nl*pow(1.0001 - nv, darkness - 1.0);\n\t}\n}\n\nfloat fresnel_fac(vec3 view, vec3 vn, float grad, float fac)\n{\n\tfloat t1, t2;\n\tfloat ffac;\n\n\tif(fac==0.0) {\n\t\tffac = 1.0;\n\t}\n\telse {\n\t\tt1= dot(view, vn);\n\t\tif(t1>0.0)  t2= 1.0+t1;\n\t\telse t2= 1.0-t1;\n\n\t\tt2= grad + (1.0-grad)*pow(t2, fac);\n\n\t\tif(t2<0.0) ffac = 0.0;\n\t\telse if(t2>1.0) ffac = 1.0;\n\t\telse ffac = t2;\n\t}\n\n\treturn ffac;\n}\n\nvoid shade_diffuse_fresnel(vec3 vn, vec3 lv, vec3 view, float fac_i, float fac, out float is)\n{\n\tis = fresnel_fac(lv, vn, fac_i, fac);\n}\n\nvoid shade_cubic(float is, out float outis)\n{\n\tif(is>0.0 && is<1.0)\n\t\toutis= smoothstep(0.0, 1.0, is);\n\telse\n\t\toutis= is;\n}\n\nvoid shade_visifac(float i, float visifac, float refl, out float outi)\n{\n\t/*if(i > 0.0)*/\n\t\touti = max(i*visifac*refl, 0.0);\n\t/*else\n\t\touti = i;*/\n}\n\nvoid shade_tangent_v_spec(vec3 tang, out vec3 vn)\n{\n\tvn = tang;\n}\n\nvoid shade_add_to_diffuse(float i, vec3 lampcol, vec3 col, out vec3 outcol)\n{\n\tif(i > 0.0)\n\t\toutcol = i*lampcol*col;\n\telse\n\t\toutcol = vec3(0.0, 0.0, 0.0);\n}\n\nvoid shade_hemi_spec(vec3 vn, vec3 lv, vec3 view, float spec, float hard, float visifac, out float t)\n{\n\tlv += view;\n\tlv = normalize(lv);\n\n\tt = dot(vn, lv);\n\tt = 0.5*t + 0.5;\n\n\tt = visifac*spec*pow(t, hard);\n}\n\nvoid shade_phong_spec(vec3 n, vec3 l, vec3 v, float hard, out float specfac)\n{\n\tvec3 h = normalize(l + v);\n\tfloat rslt = max(dot(h, n), 0.0);\n\n\tspecfac = pow(rslt, hard);\n}\n\nvoid shade_cooktorr_spec(vec3 n, vec3 l, vec3 v, float hard, out float specfac)\n{\n\tvec3 h = normalize(v + l);\n\tfloat nh = dot(n, h);\n\n\tif(nh < 0.0) {\n\t\tspecfac = 0.0;\n\t}\n\telse {\n\t\tfloat nv = max(dot(n, v), 0.0);\n\t\tfloat i = pow(nh, hard);\n\n\t\ti = i/(0.1+nv);\n\t\tspecfac = i;\n\t}\n}\n\nvoid shade_blinn_spec(vec3 n, vec3 l, vec3 v, float refrac, float spec_power, out float specfac)\n{\n\tif(refrac < 1.0) {\n\t\tspecfac = 0.0;\n\t}\n\telse if(spec_power == 0.0) {\n\t\tspecfac = 0.0;\n\t}\n\telse {\n\t\tif(spec_power<100.0)\n\t\t\tspec_power= sqrt(1.0/spec_power);\n\t\telse\n\t\t\tspec_power= 10.0/spec_power;\n\n\t\tvec3 h = normalize(v + l);\n\t\tfloat nh = dot(n, h);\n\t\tif(nh < 0.0) {\n\t\t\tspecfac = 0.0;\n\t\t}\n\t\telse {\n\t\t\tfloat nv = max(dot(n, v), 0.01);\n\t\t\tfloat nl = dot(n, l);\n\t\t\tif(nl <= 0.01) {\n\t\t\t\tspecfac = 0.0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfloat vh = max(dot(v, h), 0.01);\n\n\t\t\t\tfloat a = 1.0;\n\t\t\t\tfloat b = (2.0*nh*nv)/vh;\n\t\t\t\tfloat c = (2.0*nh*nl)/vh;\n\n\t\t\t\tfloat g = 0.0;\n\n\t\t\t\tif(a < b && a < c) g = a;\n\t\t\t\telse if(b < a && b < c) g = b;\n\t\t\t\telse if(c < a && c < b) g = c;\n\n\t\t\t\tfloat p = sqrt(((refrac * refrac)+(vh*vh)-1.0));\n\t\t\t\tfloat f = (((p-vh)*(p-vh))/((p+vh)*(p+vh)))*(1.0+((((vh*(p+vh))-1.0)*((vh*(p+vh))-1.0))/(((vh*(p-vh))+1.0)*((vh*(p-vh))+1.0))));\n\t\t\t\tfloat ang = acos(nh);\n\n\t\t\t\tspecfac = max(f*g*exp_blender((-(ang*ang)/(2.0*spec_power*spec_power))), 0.0);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid shade_wardiso_spec(vec3 n, vec3 l, vec3 v, float rms, out float specfac)\n{\n\tvec3 h = normalize(l + v);\n\tfloat nh = max(dot(n, h), 0.001);\n\tfloat nv = max(dot(n, v), 0.001);\n\tfloat nl = max(dot(n, l), 0.001);\n\tfloat angle = tan(acos(nh));\n\tfloat alpha = max(rms, 0.001);\n\n\tspecfac= nl * (1.0/(4.0*M_PI*alpha*alpha))*(exp_blender(-(angle*angle)/(alpha*alpha))/(sqrt(nv*nl)));\n}\n\nvoid shade_toon_spec(vec3 n, vec3 l, vec3 v, float size, float tsmooth, out float specfac)\n{\n\tvec3 h = normalize(l + v);\n\tfloat rslt = dot(h, n);\n\tfloat ang = acos(rslt);\n\n\tif(ang < size) rslt = 1.0;\n\telse if(ang >= (size + tsmooth) || tsmooth == 0.0) rslt = 0.0;\n\telse rslt = 1.0 - ((ang - size)/tsmooth);\n\n\tspecfac = rslt;\n}\n\nvoid shade_spec_area_inp(float specfac, float inp, out float outspecfac)\n{\n\toutspecfac = specfac*inp;\n}\n\nvoid shade_spec_t(float shadfac, float spec, float visifac, float specfac, out float t)\n{\n\tt = shadfac*spec*visifac*specfac;\n}\n\nvoid shade_add_spec(float t, vec3 lampcol, vec3 speccol, out vec3 outcol)\n{\n\toutcol = t*lampcol*speccol;\n}\n\nvoid shade_add(vec4 col1, vec4 col2, out vec4 outcol)\n{\n\toutcol = col1 + col2;\n}\n\nvoid shade_madd(vec4 col, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\toutcol = col + col1*col2;\n}\n\nvoid shade_add_clamped(vec4 col1, vec4 col2, out vec4 outcol)\n{\n\toutcol = col1 + max(col2, vec4(0.0, 0.0, 0.0, 0.0));\n}\n\nvoid shade_madd_clamped(vec4 col, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\toutcol = col + max(col1*col2, vec4(0.0, 0.0, 0.0, 0.0));\n}\n\nvoid shade_maddf(vec4 col, float f, vec4 col1, out vec4 outcol)\n{\n\toutcol = col + f*col1;\n}\n\nvoid shade_mul(vec4 col1, vec4 col2, out vec4 outcol)\n{\n\toutcol = col1*col2;\n}\n\nvoid shade_mul_value(float fac, vec4 col, out vec4 outcol)\n{\n\toutcol = col*fac;\n}\n\nvoid shade_obcolor(vec4 col, vec4 obcol, out vec4 outcol)\n{\n\toutcol = vec4(col.rgb*obcol.rgb, col.a);\n}\n\nvoid ramp_rgbtobw(vec3 color, out float outval)\n{\n\toutval = color.r*0.3 + color.g*0.58 + color.b*0.12;\n}\n\nvoid shade_only_shadow(float i, float shadfac, float energy, vec3 shadcol, out vec3 outshadrgb)\n{\n\toutshadrgb = i*energy*(1.0 - shadfac)*(vec3(1.0)-shadcol);\n}\n\nvoid shade_only_shadow_diffuse(vec3 shadrgb, vec3 rgb, vec4 diff, out vec4 outdiff)\n{\n\toutdiff = diff - vec4(rgb*shadrgb, 0.0);\n}\n\nvoid shade_only_shadow_specular(vec3 shadrgb, vec3 specrgb, vec4 spec, out vec4 outspec)\n{\n\toutspec = spec - vec4(specrgb*shadrgb, 0.0);\n}\n\nvoid shade_clamp_positive(vec4 col, out vec4 outcol)\n{\n\toutcol = max(col, vec4(0.0));\n}\n\nvoid test_shadowbuf(vec3 rco, sampler2D shadowmap, mat4 shadowpersmat, float shadowbias, float inp, out float result)\n{\n\tif(inp <= 0.0) {\n\t\tresult = 0.0;\n\t}\n\telse {\n\t\tvec4 co = shadowpersmat*vec4(rco, 1.0);\n\n\t\t//float bias = (1.5 - inp*inp)*shadowbias;\n\t\tco.z -= shadowbias*co.w;\n\t\t\n\t\tif (co.w > 0.0 && co.x > 0.0 && co.x/co.w < 1.0 && co.y > 0.0 && co.y/co.w < 1.0)\n\t\t\tresult = step(co.z,texture2D(shadowmap, co.xy).x);\n\t\telse\n\t\t\tresult = 1.0;\n\t}\n}\n\nvoid test_shadowbuf_vsm(vec3 rco, sampler2D shadowmap, mat4 shadowpersmat, float shadowbias, float bleedbias, float inp, out float result)\n{\n\tif(inp <= 0.0) {\n\t\tresult = 0.0;\n\t}\n\telse {\n\t\tvec4 co = shadowpersmat*vec4(rco, 1.0);\n\t\tif (co.w > 0.0 && co.x > 0.0 && co.x/co.w < 1.0 && co.y > 0.0 && co.y/co.w < 1.0) {\n\t\t\tvec2 moments = texture2DProj(shadowmap, co).rg;\n\t\t\tfloat dist = co.z/co.w;\n\t\t\tfloat p = 0.0;\n\t\t\t\n\t\t\tif(dist <= moments.x)\n\t\t\t\tp = 1.0;\n\n\t\t\tfloat variance = moments.y - (moments.x*moments.x);\n\t\t\tvariance = max(variance, shadowbias/10.0);\n\n\t\t\tfloat d = moments.x - dist;\n\t\t\tfloat p_max = variance / (variance + d*d);\n\n\t\t\t// Now reduce light-bleeding by removing the [0, x] tail and linearly rescaling (x, 1]\n\t\t\tp_max = clamp((p_max-bleedbias)/(1.0-bleedbias), 0.0, 1.0);\n\n\t\t\tresult = max(p, p_max);\n\t\t}\n\t\telse {\n\t\t\tresult = 1.0;\n\t\t}\n\t}\n}\n\nvoid shadows_only(vec3 rco, sampler2D shadowmap, mat4 shadowpersmat, float shadowbias, vec3 shadowcolor, float inp, out vec3 result)\n{\n\tresult = vec3(1.0);\n\n\tif(inp > 0.0) {\n\t\tfloat shadfac;\n\n\t\ttest_shadowbuf(rco, shadowmap, shadowpersmat, shadowbias, inp, shadfac);\n\t\tresult -= (1.0 - shadfac) * (vec3(1.0) - shadowcolor);\n\t}\n}\n\nvoid shadows_only_vsm(vec3 rco, sampler2D shadowmap, mat4 shadowpersmat, float shadowbias, float bleedbias, vec3 shadowcolor, float inp, out vec3 result)\n{\n\tresult = vec3(1.0);\n\n\tif(inp > 0.0) {\n\t\tfloat shadfac;\n\n\t\ttest_shadowbuf_vsm(rco, shadowmap, shadowpersmat, shadowbias, bleedbias, inp, shadfac);\n\t\tresult -= (1.0 - shadfac) * (vec3(1.0) - shadowcolor);\n\t}\n}\n\nvoid shade_light_texture(vec3 rco, sampler2D cookie, mat4 shadowpersmat, out vec4 result)\n{\n\n\tvec4 co = shadowpersmat*vec4(rco, 1.0);\n\n\tresult = texture2DProj(cookie, co);\n}\n\nvoid shade_exposure_correct(vec3 col, float linfac, float logfac, out vec3 outcol)\n{\n\toutcol = linfac*(1.0 - exp(col*logfac));\n}\n\nvoid shade_mist_factor(vec3 co, float miststa, float mistdist, float misttype, float misi, out float outfac)\n{\n\tfloat fac, zcor;\n\n\tzcor = (0.0 == 0.0)? length(co): -co[2];\n\t\n\tfac = clamp((zcor-miststa)/mistdist, 0.0, 1.0);\n\tif(misttype == 0.0) fac *= fac;\n\telse if(misttype == 1.0);\n\telse fac = sqrt(fac);\n\n\toutfac = 1.0 - (1.0-fac)*(1.0-misi);\n}\n\nvoid shade_world_mix(vec3 hor, vec4 col, out vec4 outcol)\n{\n\tfloat fac = clamp(col.a, 0.0, 1.0);\n\toutcol = vec4(mix(hor, col.rgb, fac), col.a);\n}\n\nvoid shade_alpha_opaque(vec4 col, out vec4 outcol)\n{\n\toutcol = vec4(col.rgb, 1.0);\n}\n\nvoid shade_alpha_obcolor(vec4 col, vec4 obcol, out vec4 outcol)\n{\n\toutcol = vec4(col.rgb, col.a*obcol.a);\n}\n\n/*********** NEW SHADER UTILITIES **************/\n\nfloat fresnel_dielectric(vec3 Incoming, vec3 Normal, float eta)\n{\n\t/* compute fresnel reflectance without explicitly computing\n\t * the refracted direction */\n\tfloat c = abs(dot(Incoming, Normal));\n\tfloat g = eta * eta - 1.0 + c * c;\n\tfloat result;\n\n\tif(g > 0.0) {\n\t\tg = sqrt(g);\n\t\tfloat A =(g - c)/(g + c);\n\t\tfloat B =(c *(g + c)- 1.0)/(c *(g - c)+ 1.0);\n\t\tresult = 0.5 * A * A *(1.0 + B * B);\n\t}\n\telse {\n\t\tresult = 1.0;  /* TIR (no refracted component) */\n\t}\n\n\treturn result;\n}\n\nfloat hypot(float x, float y)\n{\n\treturn sqrt(x*x + y*y);\n}\n\n/*********** NEW SHADER NODES ***************/\n\n#define NUM_LIGHTS 3\n\n/* bsdfs */\n\nvoid node_bsdf_diffuse(vec4 color, float roughness, vec3 N, out vec4 result)\n{\n\t/* ambient light */\n\tvec3 L = vec3(0.2);\n\n\t/* directional lights */\n\tfor(int i = 0; i < NUM_LIGHTS; i++) {\n\t\tvec3 light_position = vec3(0,0,0).xyz;\n\t\tvec3 light_diffuse = vec3(0,0,0).rgb;\n\n\t\tfloat bsdf = max(dot(N, light_position), 0.0);\n\t\tL += light_diffuse*bsdf;\n\t}\n\n\tresult = vec4(L*color.rgb, 1.0);\n}\n\nvoid node_bsdf_glossy(vec4 color, float roughness, vec3 N, out vec4 result)\n{\n\t/* ambient light */\n\tvec3 L = vec3(0.2);\n\n\t/* directional lights */\n\tfor(int i = 0; i < NUM_LIGHTS; i++) {\n\t\tvec3 light_position = vec3(0,0,0).xyz;\n\t\tvec3 H = vec3(0,0,0).xyz;\n\t\tvec3 light_diffuse = vec3(0,0,0).rgb;\n\t\tvec3 light_specular = vec3(0,0,0).rgb;\n\n\t\t/* we mix in some diffuse so low roughness still shows up */\n\t\tfloat bsdf = 0.5*pow(max(dot(N, H), 0.0), 1.0/roughness);\n\t\tbsdf += 0.5*max(dot(N, light_position), 0.0);\n\t\tL += light_specular*bsdf;\n\t}\n\n\tresult = vec4(L*color.rgb, 1.0);\n}\n\nvoid node_bsdf_anisotropic(vec4 color, float roughness, float anisotropy, float rotation, vec3 N, vec3 T, out vec4 result)\n{\n\tnode_bsdf_diffuse(color, 0.0, N, result);\n}\n\nvoid node_bsdf_glass(vec4 color, float roughness, float ior, vec3 N, out vec4 result)\n{\n\tnode_bsdf_diffuse(color, 0.0, N, result);\n}\n\nvoid node_bsdf_toon(vec4 color, float size, float tsmooth, vec3 N, out vec4 result)\n{\n\tnode_bsdf_diffuse(color, 0.0, N, result);\n}\n\nvoid node_bsdf_translucent(vec4 color, vec3 N, out vec4 result)\n{\n\tnode_bsdf_diffuse(color, 0.0, N, result);\n}\n\nvoid node_bsdf_transparent(vec4 color, out vec4 result)\n{\n\t/* this isn't right */\n\tresult.r = color.r;\n\tresult.g = color.g;\n\tresult.b = color.b;\n\tresult.a = 0.0;\n}\n\nvoid node_bsdf_velvet(vec4 color, float sigma, vec3 N, out vec4 result)\n{\n\tnode_bsdf_diffuse(color, 0.0, N, result);\n}\n\nvoid node_subsurface_scattering(vec4 color, float scale, vec3 radius, float sharpen, float texture_blur, vec3 N, out vec4 result)\n{\n\tnode_bsdf_diffuse(color, 0.0, N, result);\n}\n\nvoid node_bsdf_hair(vec4 color, float offset, float roughnessu, float roughnessv, out vec4 result)\n{\n\tresult = color;\n}\n\n/* emission */\n\nvoid node_emission(vec4 color, float strength, vec3 N, out vec4 result)\n{\n\tresult = color*strength;\n}\n\n/* closures */\n\nvoid node_mix_shader(float fac, vec4 shader1, vec4 shader2, out vec4 shader)\n{\n\tshader = mix(shader1, shader2, fac);\n}\n\nvoid node_add_shader(vec4 shader1, vec4 shader2, out vec4 shader)\n{\n\tshader = shader1 + shader2;\n}\n\n/* fresnel */\n\nvoid node_fresnel(float ior, vec3 N, vec3 I, out float result)\n{\n\t/* handle perspective/orthographic */\n\tvec3 I_view = (0.0 == 0.0)? normalize(I): vec3(0.0, 0.0, -1.0);\n\n\tfloat eta = max(ior, 0.00001);\n\tresult = fresnel_dielectric(I_view, N, (gl_FrontFacing)? eta: 1.0/eta);\n}\n\n/* layer_weight */\n\nvoid node_layer_weight(float blend, vec3 N, vec3 I, out float fresnel, out float facing)\n{\n\t/* fresnel */\n\tfloat eta = max(1.0 - blend, 0.00001);\n\tfresnel = fresnel_dielectric(normalize(I), N, (gl_FrontFacing)? 1.0/eta : eta );\n\n\t/* facing */\n\tfacing = abs(dot(normalize(I), N));\n\tif(blend != 0.5) {\n\t\tblend = clamp(blend, 0.0, 0.99999);\n\t\tblend = (blend < 0.5)? 2.0*blend: 0.5/(1.0 - blend);\n\t\tfacing = pow(facing, blend);\n\t}\n\tfacing = 1.0 - facing;\n}\n\n/* gamma */\n\nvoid node_gamma(vec4 col, float gamma, out vec4 outcol)\n{\n\toutcol = col;\n\n\tif(col.r > 0.0)\n\t\toutcol.r = compatible_pow(col.r, gamma);\n\tif(col.g > 0.0)\n\t\toutcol.g = compatible_pow(col.g, gamma);\n\tif(col.b > 0.0)\n\t\toutcol.b = compatible_pow(col.b, gamma);\n}\n\n/* geometry */\n\nvoid node_attribute(vec3 attr_uv, out vec4 outcol, out vec3 outvec, out float outf)\n{\n\toutcol = vec4(attr_uv, 1.0);\n\toutvec = attr_uv;\n\toutf = (attr_uv.x + attr_uv.y + attr_uv.z)/3.0;\n}\n\nvoid node_geometry(vec3 I, vec3 N, mat4 toworld,\n\tout vec3 position, out vec3 normal, out vec3 tangent,\n\tout vec3 true_normal, out vec3 incoming, out vec3 parametric,\n\tout float backfacing)\n{\n\tposition = (toworld*vec4(I, 1.0)).xyz;\n\tnormal = (toworld*vec4(N, 0.0)).xyz;\n\ttangent = vec3(0.0);\n\ttrue_normal = normal;\n\n\t/* handle perspective/orthographic */\n\tvec3 I_view = (0.0 == 0.0)? normalize(I): vec3(0.0, 0.0, -1.0);\n\tincoming = -(toworld*vec4(I_view, 0.0)).xyz;\n\n\tparametric = vec3(0.0);\n\tbackfacing = (gl_FrontFacing)? 0.0: 1.0;\n}\n\nvoid node_tex_coord(vec3 I, vec3 N, mat4 viewinvmat, mat4 obinvmat,\n\tvec3 attr_orco, vec3 attr_uv,\n\tout vec3 generated, out vec3 normal, out vec3 uv, out vec3 object,\n\tout vec3 camera, out vec3 window, out vec3 reflection)\n{\n\tgenerated = attr_orco;\n\tnormal = normalize((obinvmat*(viewinvmat*vec4(N, 0.0))).xyz);\n\tuv = attr_uv;\n\tobject = (obinvmat*(viewinvmat*vec4(I, 1.0))).xyz;\n\tcamera = I;\n\twindow = gl_FragCoord.xyz;\n\treflection = reflect(N, I);\n\n}\n\n/* textures */\n\nvoid node_tex_gradient(vec3 co, out vec4 color, out float fac)\n{\n\tcolor = vec4(1.0);\n\tfac = 1.0;\n}\n\nvoid node_tex_checker(vec3 co, vec4 color1, vec4 color2, float scale, out vec4 color, out float fac)\n{\n\tcolor = vec4(1.0);\n\tfac = 1.0;\n}\n\nvoid node_tex_brick(vec3 co, vec4 color1, vec4 color2, vec4 mortar, float scale, float mortar_size, float bias, float brick_width, float row_height, out vec4 color, out float fac)\n{\n\tcolor = vec4(1.0);\n\tfac = 1.0;\n}\n\nvoid node_tex_clouds(vec3 co, float size, out vec4 color, out float fac)\n{\n\tcolor = vec4(1.0);\n\tfac = 1.0;\n}\n\nvoid node_tex_environment(vec3 co, sampler2D ima, out vec4 color)\n{\n\tfloat u = (atan(co.y, co.x) + M_PI)/(2.0*M_PI);\n\tfloat v = atan(co.z, hypot(co.x, co.y))/M_PI + 0.5;\n\n\tcolor = texture2D(ima, vec2(u, v));\n}\n\nvoid node_tex_environment_empty(vec3 co, out vec4 color)\n{\n\tcolor = vec4(0.0);\n}\n\nvoid node_tex_image(vec3 co, sampler2D ima, out vec4 color, out float alpha)\n{\n\tcolor = texture2D(ima, co.xy);\n\talpha = color.a;\n}\n\nvoid node_tex_image_empty(vec3 co, out vec4 color, out float alpha)\n{\n\tcolor = vec4(0.0);\n\talpha = 0.0;\n}\n\nvoid node_tex_magic(vec3 p, float scale, float distortion, out vec4 color, out float fac)\n{\n\tcolor = vec4(1.0);\n\tfac = 1.0;\n}\n\nvoid node_tex_musgrave(vec3 co, float scale, float detail, float dimension, float lacunarity, float offset, float gain, out vec4 color, out float fac)\n{\n\tcolor = vec4(1.0);\n\tfac = 1.0;\n}\n\nvoid node_tex_noise(vec3 co, float scale, float detail, float distortion, out vec4 color, out float fac)\n{\n\tcolor = vec4(1.0);\n\tfac = 1.0;\n}\n\nvoid node_tex_sky(vec3 co, out vec4 color)\n{\n\tcolor = vec4(1.0);\n}\n\nvoid node_tex_voronoi(vec3 co, float scale, out vec4 color, out float fac)\n{\n\tcolor = vec4(1.0);\n\tfac = 1.0;\n}\n\nvoid node_tex_wave(vec3 co, float scale, float distortion, float detail, float detail_scale, out vec4 color, out float fac)\n{\n\tcolor = vec4(1.0);\n\tfac = 1.0;\n}\n\n/* light path */\n\nvoid node_light_path(\n\tout float is_camera_ray,\n\tout float is_shadow_ray,\n\tout float is_diffuse_ray,\n\tout float is_glossy_ray,\n\tout float is_singular_ray,\n\tout float is_reflection_ray,\n\tout float is_transmission_ray,\n\tout float ray_length,\n\tout float ray_depth,\n\tout float transparent_depth)\n{\n\tis_camera_ray = 1.0;\n\tis_shadow_ray = 0.0;\n\tis_diffuse_ray = 0.0;\n\tis_glossy_ray = 0.0;\n\tis_singular_ray = 0.0;\n\tis_reflection_ray = 0.0;\n\tis_transmission_ray = 0.0;\n\tray_length = 1.0;\n\tray_depth = 1.0;\n\ttransparent_depth = 1.0;\n}\n\nvoid node_light_falloff(float strength, float tsmooth, out float quadratic, out float linear, out float constant)\n{\n\tquadratic = strength;\n\tlinear = strength;\n\tconstant = strength;\n}\n\nvoid node_object_info(out vec3 location, out float object_index, out float material_index, out float random)\n{\n\tlocation = vec3(0.0);\n\tobject_index = 0.0;\n\tmaterial_index = 0.0;\n\trandom = 0.0;\n}\n\nvoid node_normal_map(float strength, vec4 color, vec3 N, out vec3 result)\n{\n\tresult = N;\n}\n\nvoid node_bump(float strength, float dist, float height, vec3 N, out vec3 result)\n{\n\tresult = N;\n}\n\n/* output */\n\nvoid node_output_material(vec4 surface, vec4 volume, float displacement, out vec4 result)\n{\n\tresult = surface;\n}\n\n/* ********************** matcap style render ******************** */\n\nvoid material_preview_matcap(vec4 color, sampler2D ima, vec4 N, vec4 mask, out vec4 result)\n{\n\tvec3 normal;\n\tvec2 tex;\n\t\n\t/* remap to 0.0 - 1.0 range. This is done because OpenGL 2.0 clamps colors \n\t * between shader stages and we want the full range of the normal */\n\tnormal = vec3(2.0, 2.0, 2.0) * vec3(N.x, N.y, N.z) - vec3(1.0, 1.0, 1.0);\n\tif (normal.z < 0.0) {\n\t\tnormal.z = 0.0;\n\t}\n\tnormal = normalize(normal);\n\n\ttex.x = 0.5 + 0.49 * normal.x;\n\ttex.y = 0.5 + 0.49 * normal.y;\n\tresult = texture2D(ima, tex) * mask;\n}", "type": "SHADER_LIB"},{"name": "metal", "double_sided": false, "type": "MATERIAL", "params": [{"specular_color": [1.0, 0.8535348176956177, 0.9847338795661926], "specular_hardness": 1, "specular_intensity": 1.0, "diffuse_color": [0.7949158549308777, 1.0, 0.8575833439826965], "emit": 0.009999999776482582, "diffuse_intensity": 1.0}], "attributes": [{"varname": "att0", "datatype": 3, "number": 1, "name": 0, "type": 5}], "uniforms": [{"size": 255043, "varname": "samp0", "texnumber": 0, "filepath": "roorh.jpg", "filter": true, "datatype": 1, "image": "roorh", "wrap": "R", "type": 13}, {"size": 3257, "varname": "samp1", "texnumber": 1, "filepath": "noise.jpg", "filter": true, "datatype": 1, "image": "noise", "wrap": "R", "type": 13}, {"size": 4131, "varname": "samp2", "texnumber": 2, "filepath": "environ.jpg", "filter": true, "datatype": 1, "image": "environ", "wrap": "R", "type": 13}, {"varname": "unf75", "datatype": 4, "lamp": "Lamp", "type": 6}, {"varname": "samp3", "texnumber": 3, "texsize": 65536, "datatype": 1, "lamp": "Lamp", "type": 14}, {"varname": "unf88", "datatype": 7, "lamp": "Lamp", "type": 9}, {"varname": "unf94", "datatype": 5, "lamp": "Lamp", "type": 11}, {"varname": "unf119", "datatype": 4, "lamp": "Lamp", "type": 11}], "scene": "Scene", "fragment": "\n\r\nvarying vec3 varnormal;\nvarying vec3 varposition;\nvarying vec2 var0;\nuniform sampler2D samp0;\nconst vec3 cons17 = vec3(0.794916, 1.000000, 0.857583);\nconst float cons20 = float(1.000000);\nconst vec3 cons25 = vec3(20.000000, 20.000000, 1.000000);\nconst vec3 cons28 = vec3(-9.500000, -9.500000, 0.000000);\nuniform sampler2D samp1;\nconst float cons36 = float(0.139827);\nconst float cons37 = float(1.000000);\nconst float cons39 = float(1.000000);\nconst float cons42 = float(1.000000);\nuniform sampler2D samp2;\nconst float cons63 = float(0.713178);\nconst float cons64 = float(1.000000);\nconst float cons71 = float(0.240000);\nuniform vec3 unf75;\nconst float cons84 = float(1.000000);\nuniform sampler2D samp3;\nuniform mat4 unf88;\nconst float cons89 = float(0.000005);\nconst float cons90 = float(0.100000);\nuniform vec4 unf94;\nconst vec4 cons100 = vec4(0.013496, 0.075797, 0.201898, 0.000005);\nconst float cons114 = float(1.000000);\nuniform vec3 unf119;\nconst vec3 cons120 = vec3(1.000000, 0.853535, 0.984734);\nconst float cons133 = float(1.000000);\nconst float cons138 = float(1.000000);\nconst vec3 cons141 = vec3(0.000000, 0.000000, 1.000000);\nconst float cons145 = float(7.420000);\nconst float cons146 = float(0.880000);\nconst vec4 cons149 = vec4(0.000000, 0.000000, 0.000000, 1.000000);\nconst vec3 cons153 = vec3(0.000000, 0.000000, 1.000000);\nconst float cons157 = float(12.710003);\nconst float cons158 = float(0.460000);\nconst float cons164 = float(1.000000);\nconst vec4 cons166 = vec4(1.000000, 0.942407, 0.781445, 1.000000);\nconst float cons169 = float(1.000000);\n\nvoid main(void)\n{\n\tvec3 facingnormal = (gl_FrontFacing)? varnormal: -varnormal;\n\tvec3 tmp2;\n\tvec3 tmp4;\n\tvec3 tmp6;\n\tfloat tmp9;\n\tvec4 tmp10;\n\tvec4 tmp12;\n\tfloat tmp14;\n\tvec4 tmp16;\n\tvec3 tmp21;\n\tvec3 tmp23;\n\tvec3 tmp26;\n\tvec3 tmp29;\n\tfloat tmp32;\n\tvec4 tmp33;\n\tfloat tmp35;\n\tfloat tmp38;\n\tfloat tmp40;\n\tfloat tmp45;\n\tfloat tmp47;\n\tvec3 tmp50;\n\tvec3 tmp52;\n\tfloat tmp55;\n\tvec4 tmp56;\n\tvec4 tmp58;\n\tfloat tmp60;\n\tvec4 tmp62;\n\tfloat tmp65;\n\tvec3 tmp70;\n\tvec4 tmp73;\n\tvec3 tmp74;\n\tvec3 tmp76;\n\tfloat tmp77;\n\tfloat tmp78;\n\tfloat tmp81;\n\tfloat tmp85;\n\tfloat tmp92;\n\tvec4 tmp95;\n\tfloat tmp97;\n\tvec4 tmp101;\n\tfloat tmp103;\n\tvec4 tmp107;\n\tfloat tmp112;\n\tfloat tmp117;\n\tvec3 tmp121;\n\tvec4 tmp124;\n\tvec4 tmp126;\n\tvec4 tmp128;\n\tvec4 tmp131;\n\tvec4 tmp134;\n\tvec4 tmp136;\n\tvec4 tmp139;\n\tvec3 tmp142;\n\tfloat tmp143;\n\tfloat tmp147;\n\tvec4 tmp151;\n\tvec3 tmp154;\n\tfloat tmp155;\n\tfloat tmp159;\n\tvec4 tmp163;\n\tvec4 tmp167;\n\tvec4 tmp170;\n\tvec4 tmp172;\n\n\tshade_norm(facingnormal, tmp2);\n\tshade_view(varposition, tmp4);\n\ttexco_uv(var0, tmp6);\n\tmtex_image(tmp6, samp0, tmp9, tmp10);\n\tset_rgba(tmp10, tmp12);\n\tmtex_alpha_from_col(tmp10, tmp14);\n\tsrgb_to_linearrgb(tmp12, tmp16);\n\tmtex_rgb_mul(cons17, tmp16.rgb, tmp14, cons20, tmp21);\n\ttexco_uv(var0, tmp23);\n\tmtex_mapping_size(tmp23, cons25, tmp26);\n\tmtex_mapping_ofs(tmp26, cons28, tmp29);\n\tmtex_image(tmp29, samp1, tmp32, tmp33);\n\tmtex_rgbtoint(tmp33, tmp35);\n\tmath_multiply(cons36, cons37, tmp38);\n\tmtex_har_divide(cons39, tmp40);\n\tmtex_value_blend(tmp40, cons42, tmp35, tmp38, tmp45);\n\tmtex_har_multiply_clamp(tmp45, tmp47);\n\ttexco_refl(tmp2, tmp4, tmp50);\n\tmtex_2d_mapping(tmp50, tmp52);\n\tmtex_image(tmp52, samp2, tmp55, tmp56);\n\tset_rgba(tmp56, tmp58);\n\tmtex_alpha_from_col(tmp56, tmp60);\n\tsrgb_to_linearrgb(tmp58, tmp62);\n\tmath_multiply(cons63, cons64, tmp65);\n\tmtex_rgb_mul(tmp21, tmp62.rgb, tmp60, tmp65, tmp70);\n\tshade_mul_value(cons71, vec4(tmp70, 1.0), tmp73);\n\tset_rgb_zero(tmp74);\n\tlamp_visibility_sun_hemi(unf75, tmp76, tmp77, tmp78);\n\tshade_inp(tmp2, tmp76, tmp81);\n\tshade_visifac(tmp81, tmp78, cons84, tmp85);\n\ttest_shadowbuf_vsm(varposition, samp3, unf88, cons89, cons90, tmp81, tmp92);\n\tshade_mul_value(tmp85, unf94, tmp95);\n\tmtex_value_invert(tmp92, tmp97);\n\tmix_mult(tmp97, tmp95, cons100, tmp101);\n\tmtex_value_invert(tmp97, tmp103);\n\tshade_madd(tmp73, tmp101, vec4(tmp70, 1.0), tmp107);\n\tshade_cooktorr_spec(tmp2, tmp76, tmp4, tmp47, tmp112);\n\tshade_spec_t(tmp103, cons114, tmp78, tmp112, tmp117);\n\tshade_add_spec(tmp117, unf119, cons120, tmp121);\n\tshade_add_clamped(vec4(tmp74, 1.0), vec4(tmp121, 1.0), tmp124);\n\tshade_clamp_positive(tmp124, tmp126);\n\tshade_clamp_positive(tmp107, tmp128);\n\tshade_add(tmp128, tmp126, tmp131);\n\tmtex_alpha_to_col(tmp131, cons133, tmp134);\n\tshade_alpha_opaque(tmp134, tmp136);\n\tmtex_alpha_to_col(tmp136, cons138, tmp139);\n\tnormal(tmp2, cons141, tmp142, tmp143);\n\tsqueeze(tmp143, cons145, cons146, tmp147);\n\tmix_blend(tmp147, cons149, tmp139, tmp151);\n\tnormal(tmp2, cons153, tmp154, tmp155);\n\tsqueeze(tmp155, cons157, cons158, tmp159);\n\tmix_blend(tmp159, tmp139, tmp151, tmp163);\n\tmix_mult(cons164, tmp163, cons166, tmp167);\n\toutput_node(tmp167, cons169, tmp170);\n\tlinearrgb_to_srgb(tmp170, tmp172);\n\n\tgl_FragColor = tmp172;\n}"},{"name": "cloth", "double_sided": false, "type": "MATERIAL", "params": [{"specular_color": [1.0, 1.0, 1.0], "specular_hardness": 2, "specular_intensity": 1.0, "diffuse_color": [1.0, 1.0, 1.0], "emit": 1.9900000095367432, "diffuse_intensity": 1.0}], "attributes": [{"varname": "att1", "datatype": 3, "number": 2, "name": "UVMap", "type": 5}], "uniforms": [{"size": 255043, "varname": "samp0", "texnumber": 0, "filepath": "roorh.jpg", "filter": true, "datatype": 1, "image": "roorh", "wrap": "R", "type": 13}, {"size": 3440, "varname": "samp1", "texnumber": 1, "filepath": "cloth.png", "filter": true, "datatype": 1, "image": "cloth", "wrap": "R", "type": 13}, {"varname": "unf54", "datatype": 4, "lamp": "Lamp", "type": 6}, {"varname": "samp2", "texnumber": 2, "texsize": 65536, "datatype": 1, "lamp": "Lamp", "type": 14}, {"varname": "unf67", "datatype": 7, "lamp": "Lamp", "type": 9}, {"varname": "unf73", "datatype": 5, "lamp": "Lamp", "type": 11}, {"varname": "unf98", "datatype": 4, "lamp": "Lamp", "type": 11}, {"size": 0, "varname": "samp3", "texnumber": 3, "filepath": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAABCAYAAAAxWXB3AAAEDElEQVR4nAEBBP77AAAAAAABAQEIAgICDwMDAxcEBAQeBQUFJQYGBiwHBwcyCAgIOAkJCT4KCgpDCwsLSAwMDE0NDQ1SDg4OVg8PD1oQEBBeERERYhISEmUTExNpFBQUbBUVFW8WFhZyFxcXdRgYGHcZGRl6GhoafBsbG38cHByBHR0dhB4eHoYfHx+IICAgiiEhIYwiIiKOIyMjkCQkJJIlJSWUJiYmlicnJ5coKCiZKSkpmyoqKpwrKyueLCwsoC0tLaEuLi6jLy8vpDAwMKYxMTGnMjIyqDMzM6o0NDSrNTU1rDY2Nq43NzevODg4sDk5ObI6OjqzOzs7tDw8PLU9PT22Pj4+uD8/P7lAQEC6QUFBu0JCQrxDQ0O9REREvkVFRb9GRkbAR0dHwUhISMJJSUnDSkpKxEtLS8VMTEzGTU1Nx05OTshPT0/JUFBQylFRUctSUlLMU1NTzVRUVM5VVVXPVlZW0FdXV9BYWFjRWVlZ0lpaWtNbW1vUXFxc1V1dXdVeXl7WX19f12BgYNhhYWHYYmJi2WNjY9pkZGTbZWVl22ZmZtxnZ2fdaGho3mlpad5qamrfa2tr4GxsbOBtbW3hbm5u4W9vb+JwcHDjcXFx43JycuRzc3PkdHR05XV1deZ2dnbmd3d353h4eOd5eXnoenp66Ht7e+l8fHzpfX196n5+fup/f3/rgICA64CAgOyBgYHsgoKC7YODg+2EhITuhYWF7oaGhu6Hh4fviIiI74mJifCKiorwi4uL8IyMjPGNjY3xjo6O8Y+Pj/KQkJDykZGR8pKSkvOTk5PzlJSU85WVlfSWlpb0l5eX9JiYmPWZmZn1mpqa9Zubm/WcnJz2nZ2d9p6envafn5/2oKCg96GhofeioqL3o6Oj96SkpPilpaX4pqam+Kenp/ioqKj4qamp+aqqqvmrq6v5rKys+a2trfmurq76r6+v+rCwsPqxsbH6srKy+rOzs/q0tLT6tbW1+7a2tvu3t7f7uLi4+7m5ufu6urr7u7u7+7y8vPy9vb38vr6+/L+/v/zAwMD8wcHB/MLCwvzDw8P8xMTE/MXFxfzGxsb9x8fH/cjIyP3Jycn9ysrK/cvLy/3MzMz9zc3N/c7Ozv3Pz8/90NDQ/dHR0f3S0tL909PT/dTU1P7V1dX+1tbW/tfX1/7Y2Nj+2dnZ/tra2v7b29v+3Nzc/t3d3f7e3t7+39/f/uDg4P7h4eH+4uLi/uPj4/7k5OT+5eXl/ubm5v7n5+f+6Ojo/unp6f7q6ur+6+vr/uzs7P/t7e3/7u7u/+/v7//w8PD/8fHx//Ly8v/z8/P/9PT0//X19f/29vb/9/f3//j4+P/5+fn/+vr6//v7+//8/Pz//f39//7+/v/SZk42LSfUGAAAAABJRU5ErkJggg==", "texsize": 257, "datatype": 1, "image": "b6e7c4581a", "wrap": "C", "type": 13}, {"varname": "unfinvviewmat", "datatype": 7, "type": 3}], "scene": "Scene", "fragment": "\n\r\nvarying vec3 varposition;\nvarying vec3 varnormal;\nuniform mat4 unfinvviewmat;\nconst vec3 var0 = vec3(0.0);\nvarying vec2 var1;\nconst vec4 var2 = vec4(0.0);\nuniform sampler2D samp0;\nconst mat4 cons24 = mat4(100.000000, 0.000000, 0.000000, 0.000000, 0.000000, 100.000000, 0.000000, 0.000000, 0.000000, 0.000000, 100.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.000000);\nconst vec3 cons25 = vec3(0.000000, 0.000000, 0.000000);\nconst vec3 cons26 = vec3(1.000000, 1.000000, 1.000000);\nconst float cons27 = float(0.000000);\nconst float cons28 = float(0.000000);\nuniform sampler2D samp1;\nconst float cons37 = float(0.609091);\nconst float cons41 = float(1.000000);\nconst vec4 cons43 = vec4(1.000000, 1.000000, 1.000000, 1.000000);\nconst float cons50 = float(0.240000);\nconst vec4 cons51 = vec4(1.000000, 1.000000, 1.000000, 0.000000);\nuniform vec3 unf54;\nconst float cons63 = float(1.000000);\nuniform sampler2D samp2;\nuniform mat4 unf67;\nconst float cons68 = float(0.000005);\nconst float cons69 = float(0.100000);\nuniform vec4 unf73;\nconst vec4 cons79 = vec4(0.013496, 0.075797, 0.201898, 0.000005);\nconst vec4 cons85 = vec4(1.000000, 1.000000, 1.000000, 0.000000);\nconst float cons90 = float(2.000000);\nconst float cons93 = float(1.000000);\nuniform vec3 unf98;\nconst float cons108 = float(0.345455);\nconst float cons112 = float(1.000000);\nconst float cons116 = float(1.000000);\nconst float cons120 = float(2.610001);\nuniform sampler2D samp3;\nconst float cons124 = float(1.000000);\nconst float cons128 = float(2.610001);\nconst vec3 cons133 = vec3(0.000000, 0.000000, 1.000000);\nconst float cons137 = float(4.559999);\nconst float cons138 = float(0.120000);\nconst float cons144 = float(1.000000);\nconst vec4 cons146 = vec4(1.000000, 0.942407, 0.781445, 1.000000);\nconst float cons149 = float(1.000000);\n\nvoid main(void)\n{\n\tvec3 facingnormal = (gl_FrontFacing)? varnormal: -varnormal;\n\tvec3 tmp7;\n\tvec3 tmp8;\n\tvec3 tmp9;\n\tvec3 tmp10;\n\tvec3 tmp11;\n\tvec3 tmp12;\n\tvec4 tmp13;\n\tfloat tmp14;\n\tfloat tmp15;\n\tfloat tmp18;\n\tvec4 tmp19;\n\tvec3 tmp20;\n\tvec4 tmp22;\n\tvec3 tmp29;\n\tfloat tmp32;\n\tvec4 tmp33;\n\tvec3 tmp34;\n\tvec4 tmp36;\n\tvec4 tmp40;\n\tvec4 tmp44;\n\tvec3 tmp46;\n\tvec3 tmp48;\n\tfloat tmp49;\n\tvec4 tmp52;\n\tvec3 tmp53;\n\tvec3 tmp55;\n\tfloat tmp56;\n\tfloat tmp57;\n\tfloat tmp60;\n\tfloat tmp64;\n\tfloat tmp71;\n\tvec4 tmp74;\n\tfloat tmp76;\n\tvec4 tmp80;\n\tfloat tmp82;\n\tvec4 tmp86;\n\tfloat tmp91;\n\tfloat tmp96;\n\tvec3 tmp100;\n\tvec4 tmp103;\n\tvec4 tmp105;\n\tvec4 tmp107;\n\tvec4 tmp111;\n\tvec4 tmp115;\n\tvec4 tmp119;\n\tvec4 tmp123;\n\tvec4 tmp127;\n\tvec4 tmp131;\n\tvec3 tmp134;\n\tfloat tmp135;\n\tfloat tmp139;\n\tvec4 tmp143;\n\tvec4 tmp147;\n\tvec4 tmp150;\n\tvec4 tmp152;\n\n\tgeom(varposition, facingnormal, unfinvviewmat, var0, var1, var2, tmp7, tmp8, tmp9, tmp10, tmp11, tmp12, tmp13, tmp14, tmp15);\n\ttexture_image(tmp11, samp0, tmp18, tmp19, tmp20);\n\tsrgb_to_linearrgb(tmp19, tmp22);\n\tmapping(tmp11, cons24, cons25, cons26, cons27, cons28, tmp29);\n\ttexture_image(tmp29, samp1, tmp32, tmp33, tmp34);\n\tsrgb_to_linearrgb(tmp33, tmp36);\n\tmix_mult(cons37, tmp22, tmp36, tmp40);\n\tmix_overlay(cons41, tmp36, cons43, tmp44);\n\tshade_view(varposition, tmp46);\n\tvec_math_normalize(tmp12, tmp48, tmp49);\n\tshade_mul_value(cons50, cons51, tmp52);\n\tset_rgb_zero(tmp53);\n\tlamp_visibility_sun_hemi(unf54, tmp55, tmp56, tmp57);\n\tshade_inp(tmp48, tmp55, tmp60);\n\tshade_visifac(tmp60, tmp57, cons63, tmp64);\n\ttest_shadowbuf_vsm(varposition, samp2, unf67, cons68, cons69, tmp60, tmp71);\n\tshade_mul_value(tmp64, unf73, tmp74);\n\tmtex_value_invert(tmp71, tmp76);\n\tmix_mult(tmp76, tmp74, cons79, tmp80);\n\tmtex_value_invert(tmp76, tmp82);\n\tshade_madd(tmp52, tmp80, cons85, tmp86);\n\tshade_cooktorr_spec(tmp48, tmp55, tmp46, cons90, tmp91);\n\tshade_spec_t(tmp82, cons93, tmp57, tmp91, tmp96);\n\tshade_add_spec(tmp96, unf98, tmp22.rgb, tmp100);\n\tshade_add_clamped(vec4(tmp53, 1.0), vec4(tmp100, 1.0), tmp103);\n\tshade_clamp_positive(tmp103, tmp105);\n\tshade_clamp_positive(tmp86, tmp107);\n\tmix_mult(cons108, tmp105, tmp44, tmp111);\n\tmix_mult(cons112, tmp40, tmp107, tmp115);\n\tmix_add(cons116, tmp115, tmp111, tmp119);\n\tcurves_rgb(cons120, tmp40, samp3, tmp123);\n\tmix_mult(cons124, tmp123, tmp107, tmp127);\n\tmix_add(cons128, tmp127, tmp111, tmp131);\n\tnormal(tmp12, cons133, tmp134, tmp135);\n\tsqueeze(tmp135, cons137, cons138, tmp139);\n\tmix_blend(tmp139, tmp131, tmp119, tmp143);\n\tmix_mult(cons144, tmp143, cons146, tmp147);\n\toutput_node(tmp147, cons149, tmp150);\n\tlinearrgb_to_srgb(tmp150, tmp152);\n\n\tgl_FragColor = tmp152;\n}"},{"name": "skin", "double_sided": false, "type": "MATERIAL", "params": [{"specular_color": [1.0, 1.0, 1.0], "specular_hardness": 2, "specular_intensity": 0.0, "diffuse_color": [0.647055447101593, 0.37091171741485596, 0.19159050285816193], "emit": 0.009999999776482582, "diffuse_intensity": 0.6370967626571655}], "attributes": [{"varname": "att0", "datatype": 3, "number": 1, "name": 0, "type": 5}], "uniforms": [{"size": 255043, "varname": "samp0", "texnumber": 0, "filepath": "roorh.jpg", "filter": true, "datatype": 1, "image": "roorh", "wrap": "R", "type": 13}, {"varname": "unf23", "datatype": 4, "lamp": "Lamp", "type": 6}, {"varname": "samp1", "texnumber": 1, "texsize": 65536, "datatype": 1, "lamp": "Lamp", "type": 14}, {"varname": "unf36", "datatype": 7, "lamp": "Lamp", "type": 9}, {"varname": "unf42", "datatype": 5, "lamp": "Lamp", "type": 11}], "scene": "Scene", "fragment": "\n\r\nvarying vec3 varnormal;\nvarying vec2 var0;\nuniform sampler2D samp0;\nconst vec3 cons15 = vec3(0.647055, 0.370912, 0.191591);\nconst float cons18 = float(1.000000);\nconst float cons20 = float(0.240000);\nuniform vec3 unf23;\nconst float cons32 = float(0.637097);\nvarying vec3 varposition;\nuniform sampler2D samp1;\nuniform mat4 unf36;\nconst float cons37 = float(0.000005);\nconst float cons38 = float(0.100000);\nuniform vec4 unf42;\nconst vec4 cons48 = vec4(0.013496, 0.075797, 0.201898, 0.000005);\nconst float cons57 = float(1.000000);\nconst float cons62 = float(1.000000);\nconst float cons64 = float(1.000000);\nconst vec4 cons66 = vec4(1.000000, 0.942407, 0.781445, 1.000000);\nconst float cons69 = float(1.000000);\n\nvoid main(void)\n{\n\tvec3 facingnormal = (gl_FrontFacing)? varnormal: -varnormal;\n\tvec3 tmp2;\n\tvec3 tmp4;\n\tfloat tmp7;\n\tvec4 tmp8;\n\tvec4 tmp10;\n\tfloat tmp12;\n\tvec4 tmp14;\n\tvec3 tmp19;\n\tvec4 tmp22;\n\tvec3 tmp24;\n\tfloat tmp25;\n\tfloat tmp26;\n\tfloat tmp29;\n\tfloat tmp33;\n\tfloat tmp40;\n\tvec4 tmp43;\n\tfloat tmp45;\n\tvec4 tmp49;\n\tvec4 tmp53;\n\tvec4 tmp55;\n\tvec4 tmp58;\n\tvec4 tmp60;\n\tvec4 tmp63;\n\tvec4 tmp67;\n\tvec4 tmp70;\n\tvec4 tmp72;\n\n\tshade_norm(facingnormal, tmp2);\n\ttexco_uv(var0, tmp4);\n\tmtex_image(tmp4, samp0, tmp7, tmp8);\n\tset_rgba(tmp8, tmp10);\n\tmtex_alpha_from_col(tmp8, tmp12);\n\tsrgb_to_linearrgb(tmp10, tmp14);\n\tmtex_rgb_blend(cons15, tmp14.rgb, tmp12, cons18, tmp19);\n\tshade_mul_value(cons20, vec4(tmp19, 1.0), tmp22);\n\tlamp_visibility_sun_hemi(unf23, tmp24, tmp25, tmp26);\n\tshade_inp(tmp2, tmp24, tmp29);\n\tshade_visifac(tmp29, tmp26, cons32, tmp33);\n\ttest_shadowbuf_vsm(varposition, samp1, unf36, cons37, cons38, tmp29, tmp40);\n\tshade_mul_value(tmp33, unf42, tmp43);\n\tmtex_value_invert(tmp40, tmp45);\n\tmix_mult(tmp45, tmp43, cons48, tmp49);\n\tshade_madd(tmp22, tmp49, vec4(tmp19, 1.0), tmp53);\n\tshade_clamp_positive(tmp53, tmp55);\n\tmtex_alpha_to_col(tmp55, cons57, tmp58);\n\tshade_alpha_opaque(tmp58, tmp60);\n\tmtex_alpha_to_col(tmp60, cons62, tmp63);\n\tmix_mult(cons64, tmp63, cons66, tmp67);\n\toutput_node(tmp67, cons69, tmp70);\n\tlinearrgb_to_srgb(tmp70, tmp72);\n\n\tgl_FragColor = tmp72;\n}"},{"name": "crystal", "double_sided": false, "type": "MATERIAL", "params": [{"specular_color": [1.0, 0.42093127965927124, 0.24409735202789307], "specular_hardness": 153, "specular_intensity": 1.0, "diffuse_color": [1.0, 0.19136667251586914, 0.0], "emit": 0.0, "diffuse_intensity": 0.0}], "attributes": [{"varname": "att0", "datatype": 3, "number": 1, "name": 0, "type": 5}], "uniforms": [{"size": 255043, "varname": "samp0", "texnumber": 0, "filepath": "roorh.jpg", "filter": true, "datatype": 1, "image": "roorh", "wrap": "R", "type": 13}, {"varname": "unf38", "datatype": 4, "lamp": "Lamp", "type": 6}, {"varname": "samp1", "texnumber": 1, "texsize": 65536, "datatype": 1, "lamp": "Lamp", "type": 14}, {"varname": "unf47", "datatype": 7, "lamp": "Lamp", "type": 9}, {"varname": "unf64", "datatype": 4, "lamp": "Lamp", "type": 11}], "scene": "Scene", "fragment": "\n\r\nconst float cons1 = float(1.000000);\nconst float cons2 = float(0.240000);\nconst float cons4 = float(1.000000);\nconst float cons5 = float(0.700000);\nconst float cons10 = float(1.000000);\nvarying vec3 varnormal;\nvarying vec3 varposition;\nvarying vec2 var0;\nuniform sampler2D samp0;\nconst vec3 cons29 = vec3(1.000000, 0.191367, 0.000000);\nconst float cons32 = float(1.000000);\nuniform vec3 unf38;\nuniform sampler2D samp1;\nuniform mat4 unf47;\nconst float cons48 = float(0.000005);\nconst float cons49 = float(0.100000);\nconst float cons55 = float(0.300000);\nconst float cons56 = float(0.046362);\nconst float cons59 = float(1.000000);\nuniform vec3 unf64;\nconst vec3 cons65 = vec3(1.000000, 0.420931, 0.244097);\nconst float cons78 = float(1.000000);\nconst float cons83 = float(1.000000);\nconst float cons85 = float(1.000000);\nconst vec4 cons87 = vec4(1.000000, 0.942407, 0.781445, 1.000000);\nconst float cons90 = float(1.000000);\n\nvoid main(void)\n{\n\tvec3 facingnormal = (gl_FrontFacing)? varnormal: -varnormal;\n\tfloat tmp3;\n\tfloat tmp6;\n\tfloat tmp9;\n\tfloat tmp12;\n\tvec3 tmp14;\n\tvec3 tmp16;\n\tvec3 tmp18;\n\tfloat tmp21;\n\tvec4 tmp22;\n\tvec4 tmp24;\n\tfloat tmp26;\n\tvec4 tmp28;\n\tvec3 tmp33;\n\tvec4 tmp36;\n\tvec3 tmp37;\n\tvec3 tmp39;\n\tfloat tmp40;\n\tfloat tmp41;\n\tfloat tmp44;\n\tfloat tmp51;\n\tfloat tmp57;\n\tfloat tmp62;\n\tvec3 tmp66;\n\tvec4 tmp69;\n\tvec4 tmp71;\n\tvec4 tmp73;\n\tvec4 tmp76;\n\tvec4 tmp79;\n\tvec4 tmp81;\n\tvec4 tmp84;\n\tvec4 tmp88;\n\tvec4 tmp91;\n\tvec4 tmp93;\n\n\tmath_subtract(cons1, cons2, tmp3);\n\tmath_subtract(cons4, cons5, tmp6);\n\tmath_multiply(tmp3, tmp6, tmp9);\n\tmath_subtract(cons10, tmp9, tmp12);\n\tshade_norm(facingnormal, tmp14);\n\tshade_view(varposition, tmp16);\n\ttexco_uv(var0, tmp18);\n\tmtex_image(tmp18, samp0, tmp21, tmp22);\n\tset_rgba(tmp22, tmp24);\n\tmtex_alpha_from_col(tmp22, tmp26);\n\tsrgb_to_linearrgb(tmp24, tmp28);\n\tmtex_rgb_blend(cons29, tmp28.rgb, tmp26, cons32, tmp33);\n\tshade_mul_value(tmp12, vec4(tmp33, 1.0), tmp36);\n\tset_rgb_zero(tmp37);\n\tlamp_visibility_sun_hemi(unf38, tmp39, tmp40, tmp41);\n\tshade_inp(tmp14, tmp39, tmp44);\n\ttest_shadowbuf_vsm(varposition, samp1, unf47, cons48, cons49, tmp44, tmp51);\n\tshade_toon_spec(tmp14, tmp39, tmp16, cons55, cons56, tmp57);\n\tshade_spec_t(tmp51, cons59, tmp41, tmp57, tmp62);\n\tshade_add_spec(tmp62, unf64, cons65, tmp66);\n\tshade_add_clamped(vec4(tmp37, 1.0), vec4(tmp66, 1.0), tmp69);\n\tshade_clamp_positive(tmp69, tmp71);\n\tshade_clamp_positive(tmp36, tmp73);\n\tshade_add(tmp73, tmp71, tmp76);\n\tmtex_alpha_to_col(tmp76, cons78, tmp79);\n\tshade_alpha_opaque(tmp79, tmp81);\n\tmtex_alpha_to_col(tmp81, cons83, tmp84);\n\tmix_mult(cons85, tmp84, cons87, tmp88);\n\toutput_node(tmp88, cons90, tmp91);\n\tlinearrgb_to_srgb(tmp91, tmp93);\n\n\tgl_FragColor = tmp93;\n}"},{"name": "wood", "double_sided": false, "type": "MATERIAL", "params": [{"specular_color": [1.0, 1.0, 1.0], "specular_hardness": 511, "specular_intensity": 0.7147337198257446, "diffuse_color": [1.0, 1.0, 1.0], "emit": 0.11999999731779099, "diffuse_intensity": 0.564998984336853}], "attributes": [{"varname": "att0", "datatype": 3, "number": 1, "name": 0, "type": 5}], "uniforms": [{"size": 138473, "varname": "samp0", "texnumber": 0, "filepath": "wood.jpg", "filter": true, "datatype": 1, "image": "wood", "wrap": "R", "type": 13}, {"size": 3257, "varname": "samp1", "texnumber": 1, "filepath": "noise.jpg", "filter": true, "datatype": 1, "image": "noise", "wrap": "R", "type": 13}, {"varname": "unf61", "datatype": 4, "lamp": "Lamp", "type": 6}, {"varname": "samp2", "texnumber": 2, "texsize": 65536, "datatype": 1, "lamp": "Lamp", "type": 14}, {"varname": "unf74", "datatype": 7, "lamp": "Lamp", "type": 9}, {"varname": "unf80", "datatype": 5, "lamp": "Lamp", "type": 11}, {"varname": "unf105", "datatype": 4, "lamp": "Lamp", "type": 11}, {"varname": "unfobcolor", "datatype": 5, "type": 5}], "scene": "Scene", "fragment": "\n\r\nvarying vec3 varnormal;\nvarying vec3 varposition;\nvarying vec2 var0;\nuniform sampler2D samp0;\nconst vec3 cons17 = vec3(1.000000, 1.000000, 1.000000);\nconst float cons20 = float(1.000000);\nconst vec3 cons22 = vec3(1.000000, 1.000000, 1.000000);\nconst float cons25 = float(1.000000);\nconst vec3 cons30 = vec3(20.000000, 20.000000, 1.000000);\nconst vec3 cons33 = vec3(-9.500000, -9.500000, 0.000000);\nuniform sampler2D samp1;\nconst float cons44 = float(0.241379);\nconst float cons45 = float(1.000000);\nconst float cons55 = float(1.000000);\nconst float cons57 = float(0.240000);\nuniform vec3 unf61;\nconst float cons70 = float(0.564999);\nuniform sampler2D samp2;\nuniform mat4 unf74;\nconst float cons75 = float(0.000005);\nconst float cons76 = float(0.100000);\nuniform vec4 unf80;\nconst vec4 cons86 = vec4(0.013496, 0.075797, 0.201898, 0.000005);\nconst float cons97 = float(0.100000);\nconst float cons100 = float(0.714734);\nuniform vec3 unf105;\nconst float cons119 = float(1.000000);\nuniform vec4 unfobcolor;\nconst float cons130 = float(1.000000);\nconst float cons132 = float(1.000000);\nconst vec4 cons134 = vec4(1.000000, 0.942407, 0.781445, 1.000000);\nconst float cons137 = float(1.000000);\n\nvoid main(void)\n{\n\tvec3 facingnormal = (gl_FrontFacing)? varnormal: -varnormal;\n\tvec3 tmp2;\n\tvec3 tmp4;\n\tvec3 tmp6;\n\tfloat tmp9;\n\tvec4 tmp10;\n\tvec4 tmp12;\n\tfloat tmp14;\n\tvec4 tmp16;\n\tvec3 tmp21;\n\tvec3 tmp26;\n\tvec3 tmp28;\n\tvec3 tmp31;\n\tvec3 tmp34;\n\tfloat tmp37;\n\tvec4 tmp38;\n\tvec4 tmp40;\n\tfloat tmp41;\n\tvec4 tmp43;\n\tfloat tmp46;\n\tvec3 tmp51;\n\tvec3 tmp56;\n\tvec4 tmp59;\n\tvec3 tmp60;\n\tvec3 tmp62;\n\tfloat tmp63;\n\tfloat tmp64;\n\tfloat tmp67;\n\tfloat tmp71;\n\tfloat tmp78;\n\tvec4 tmp81;\n\tfloat tmp83;\n\tvec4 tmp87;\n\tfloat tmp89;\n\tvec4 tmp93;\n\tfloat tmp98;\n\tfloat tmp103;\n\tvec3 tmp107;\n\tvec4 tmp110;\n\tvec4 tmp112;\n\tvec4 tmp114;\n\tvec4 tmp117;\n\tvec4 tmp120;\n\tvec4 tmp123;\n\tvec4 tmp125;\n\tvec4 tmp128;\n\tvec4 tmp131;\n\tvec4 tmp135;\n\tvec4 tmp138;\n\tvec4 tmp140;\n\n\tshade_norm(facingnormal, tmp2);\n\tshade_view(varposition, tmp4);\n\ttexco_uv(var0, tmp6);\n\tmtex_image(tmp6, samp0, tmp9, tmp10);\n\tset_rgba(tmp10, tmp12);\n\tmtex_alpha_from_col(tmp10, tmp14);\n\tsrgb_to_linearrgb(tmp12, tmp16);\n\tmtex_rgb_blend(cons17, tmp16.rgb, tmp14, cons20, tmp21);\n\tmtex_rgb_blend(cons22, tmp16.rgb, tmp14, cons25, tmp26);\n\ttexco_uv(var0, tmp28);\n\tmtex_mapping_size(tmp28, cons30, tmp31);\n\tmtex_mapping_ofs(tmp31, cons33, tmp34);\n\tmtex_image(tmp34, samp1, tmp37, tmp38);\n\tset_rgba(tmp38, tmp40);\n\tset_value_one(tmp41);\n\tsrgb_to_linearrgb(tmp40, tmp43);\n\tmath_multiply(cons44, cons45, tmp46);\n\tmtex_rgb_mul(tmp21, tmp43.rgb, tmp41, tmp46, tmp51);\n\tmtex_rgb_mul(tmp26, tmp43.rgb, tmp41, cons55, tmp56);\n\tshade_mul_value(cons57, vec4(tmp51, 1.0), tmp59);\n\tset_rgb_zero(tmp60);\n\tlamp_visibility_sun_hemi(unf61, tmp62, tmp63, tmp64);\n\tshade_inp(tmp2, tmp62, tmp67);\n\tshade_visifac(tmp67, tmp64, cons70, tmp71);\n\ttest_shadowbuf_vsm(varposition, samp2, unf74, cons75, cons76, tmp67, tmp78);\n\tshade_mul_value(tmp71, unf80, tmp81);\n\tmtex_value_invert(tmp78, tmp83);\n\tmix_mult(tmp83, tmp81, cons86, tmp87);\n\tmtex_value_invert(tmp83, tmp89);\n\tshade_madd(tmp59, tmp87, vec4(tmp51, 1.0), tmp93);\n\tshade_wardiso_spec(tmp2, tmp62, tmp4, cons97, tmp98);\n\tshade_spec_t(tmp89, cons100, tmp64, tmp98, tmp103);\n\tshade_add_spec(tmp103, unf105, tmp56, tmp107);\n\tshade_add_clamped(vec4(tmp60, 1.0), vec4(tmp107, 1.0), tmp110);\n\tshade_clamp_positive(tmp110, tmp112);\n\tshade_clamp_positive(tmp93, tmp114);\n\tshade_add(tmp114, tmp112, tmp117);\n\tmtex_alpha_to_col(tmp117, cons119, tmp120);\n\tshade_obcolor(tmp120, unfobcolor, tmp123);\n\tshade_alpha_opaque(tmp123, tmp125);\n\tshade_alpha_obcolor(tmp125, unfobcolor, tmp128);\n\tmtex_alpha_to_col(tmp128, cons130, tmp131);\n\tmix_mult(cons132, tmp131, cons134, tmp135);\n\toutput_node(tmp135, cons137, tmp138);\n\tlinearrgb_to_srgb(tmp138, tmp140);\n\n\tgl_FragColor = tmp140;\n}"},{"name": "leather", "double_sided": false, "type": "MATERIAL", "params": [{"specular_color": [0.999976634979248, 0.40649691224098206, 0.1967352330684662], "specular_hardness": 9, "specular_intensity": 0.0, "diffuse_color": [0.14412850141525269, 0.05126946419477463, 0.02732088789343834], "emit": 0.0, "diffuse_intensity": 0.5155372023582458}], "attributes": [{"varname": "att1", "datatype": 3, "number": 2, "name": "UVMap", "type": 5}], "uniforms": [{"size": 255043, "varname": "samp0", "texnumber": 0, "filepath": "roorh.jpg", "filter": true, "datatype": 1, "image": "roorh", "wrap": "R", "type": 13}, {"size": 3257, "varname": "samp1", "texnumber": 1, "filepath": "noise.jpg", "filter": true, "datatype": 1, "image": "noise", "wrap": "R", "type": 13}, {"varname": "unf54", "datatype": 4, "lamp": "Lamp", "type": 6}, {"varname": "samp2", "texnumber": 2, "texsize": 65536, "datatype": 1, "lamp": "Lamp", "type": 14}, {"varname": "unf67", "datatype": 7, "lamp": "Lamp", "type": 9}, {"varname": "unf73", "datatype": 5, "lamp": "Lamp", "type": 11}, {"varname": "unf98", "datatype": 4, "lamp": "Lamp", "type": 11}, {"size": 0, "varname": "samp3", "texnumber": 3, "filepath": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAABCAYAAAAxWXB3AAAEDElEQVR4nAEBBP77AAAAAAABAQEIAgICDwMDAxcEBAQeBQUFJQYGBiwHBwcyCAgIOAkJCT4KCgpDCwsLSAwMDE0NDQ1SDg4OVg8PD1oQEBBeERERYhISEmUTExNpFBQUbBUVFW8WFhZyFxcXdRgYGHcZGRl6GhoafBsbG38cHByBHR0dhB4eHoYfHx+IICAgiiEhIYwiIiKOIyMjkCQkJJIlJSWUJiYmlicnJ5coKCiZKSkpmyoqKpwrKyueLCwsoC0tLaEuLi6jLy8vpDAwMKYxMTGnMjIyqDMzM6o0NDSrNTU1rDY2Nq43NzevODg4sDk5ObI6OjqzOzs7tDw8PLU9PT22Pj4+uD8/P7lAQEC6QUFBu0JCQrxDQ0O9REREvkVFRb9GRkbAR0dHwUhISMJJSUnDSkpKxEtLS8VMTEzGTU1Nx05OTshPT0/JUFBQylFRUctSUlLMU1NTzVRUVM5VVVXPVlZW0FdXV9BYWFjRWVlZ0lpaWtNbW1vUXFxc1V1dXdVeXl7WX19f12BgYNhhYWHYYmJi2WNjY9pkZGTbZWVl22ZmZtxnZ2fdaGho3mlpad5qamrfa2tr4GxsbOBtbW3hbm5u4W9vb+JwcHDjcXFx43JycuRzc3PkdHR05XV1deZ2dnbmd3d353h4eOd5eXnoenp66Ht7e+l8fHzpfX196n5+fup/f3/rgICA64CAgOyBgYHsgoKC7YODg+2EhITuhYWF7oaGhu6Hh4fviIiI74mJifCKiorwi4uL8IyMjPGNjY3xjo6O8Y+Pj/KQkJDykZGR8pKSkvOTk5PzlJSU85WVlfSWlpb0l5eX9JiYmPWZmZn1mpqa9Zubm/WcnJz2nZ2d9p6envafn5/2oKCg96GhofeioqL3o6Oj96SkpPilpaX4pqam+Kenp/ioqKj4qamp+aqqqvmrq6v5rKys+a2trfmurq76r6+v+rCwsPqxsbH6srKy+rOzs/q0tLT6tbW1+7a2tvu3t7f7uLi4+7m5ufu6urr7u7u7+7y8vPy9vb38vr6+/L+/v/zAwMD8wcHB/MLCwvzDw8P8xMTE/MXFxfzGxsb9x8fH/cjIyP3Jycn9ysrK/cvLy/3MzMz9zc3N/c7Ozv3Pz8/90NDQ/dHR0f3S0tL909PT/dTU1P7V1dX+1tbW/tfX1/7Y2Nj+2dnZ/tra2v7b29v+3Nzc/t3d3f7e3t7+39/f/uDg4P7h4eH+4uLi/uPj4/7k5OT+5eXl/ubm5v7n5+f+6Ojo/unp6f7q6ur+6+vr/uzs7P/t7e3/7u7u/+/v7//w8PD/8fHx//Ly8v/z8/P/9PT0//X19f/29vb/9/f3//j4+P/5+fn/+vr6//v7+//8/Pz//f39//7+/v/SZk42LSfUGAAAAABJRU5ErkJggg==", "texsize": 257, "datatype": 1, "image": "b6e7c4581a", "wrap": "C", "type": 13}, {"varname": "unfinvviewmat", "datatype": 7, "type": 3}], "scene": "Scene", "fragment": "\n\r\nvarying vec3 varposition;\nvarying vec3 varnormal;\nuniform mat4 unfinvviewmat;\nconst vec3 var0 = vec3(0.0);\nvarying vec2 var1;\nconst vec4 var2 = vec4(0.0);\nuniform sampler2D samp0;\nconst mat4 cons24 = mat4(20.000000, 0.000000, 0.000000, 0.000000, 0.000000, 20.000000, 0.000000, 0.000000, 0.000000, 0.000000, 20.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.000000);\nconst vec3 cons25 = vec3(0.000000, 0.000000, 0.000000);\nconst vec3 cons26 = vec3(1.000000, 1.000000, 1.000000);\nconst float cons27 = float(0.000000);\nconst float cons28 = float(0.000000);\nuniform sampler2D samp1;\nconst float cons37 = float(0.609091);\nconst float cons41 = float(1.000000);\nconst vec4 cons43 = vec4(1.000000, 1.000000, 1.000000, 1.000000);\nconst float cons50 = float(0.240000);\nconst vec4 cons51 = vec4(1.000000, 1.000000, 1.000000, 0.000000);\nuniform vec3 unf54;\nconst float cons63 = float(1.000000);\nuniform sampler2D samp2;\nuniform mat4 unf67;\nconst float cons68 = float(0.000005);\nconst float cons69 = float(0.100000);\nuniform vec4 unf73;\nconst vec4 cons79 = vec4(0.013496, 0.075797, 0.201898, 0.000005);\nconst vec4 cons85 = vec4(1.000000, 1.000000, 1.000000, 0.000000);\nconst float cons90 = float(2.000000);\nconst float cons93 = float(1.000000);\nuniform vec3 unf98;\nconst float cons108 = float(0.345455);\nconst float cons112 = float(1.000000);\nconst float cons116 = float(1.000000);\nconst float cons120 = float(0.580000);\nuniform sampler2D samp3;\nconst float cons124 = float(0.500000);\nconst float cons128 = float(0.580000);\nconst vec3 cons133 = vec3(0.000000, 0.000000, 1.000000);\nconst float cons137 = float(4.559999);\nconst float cons138 = float(0.120000);\nconst float cons144 = float(1.000000);\nconst vec4 cons146 = vec4(1.000000, 0.942407, 0.781445, 1.000000);\nconst float cons149 = float(1.000000);\n\nvoid main(void)\n{\n\tvec3 facingnormal = (gl_FrontFacing)? varnormal: -varnormal;\n\tvec3 tmp7;\n\tvec3 tmp8;\n\tvec3 tmp9;\n\tvec3 tmp10;\n\tvec3 tmp11;\n\tvec3 tmp12;\n\tvec4 tmp13;\n\tfloat tmp14;\n\tfloat tmp15;\n\tfloat tmp18;\n\tvec4 tmp19;\n\tvec3 tmp20;\n\tvec4 tmp22;\n\tvec3 tmp29;\n\tfloat tmp32;\n\tvec4 tmp33;\n\tvec3 tmp34;\n\tvec4 tmp36;\n\tvec4 tmp40;\n\tvec4 tmp44;\n\tvec3 tmp46;\n\tvec3 tmp48;\n\tfloat tmp49;\n\tvec4 tmp52;\n\tvec3 tmp53;\n\tvec3 tmp55;\n\tfloat tmp56;\n\tfloat tmp57;\n\tfloat tmp60;\n\tfloat tmp64;\n\tfloat tmp71;\n\tvec4 tmp74;\n\tfloat tmp76;\n\tvec4 tmp80;\n\tfloat tmp82;\n\tvec4 tmp86;\n\tfloat tmp91;\n\tfloat tmp96;\n\tvec3 tmp100;\n\tvec4 tmp103;\n\tvec4 tmp105;\n\tvec4 tmp107;\n\tvec4 tmp111;\n\tvec4 tmp115;\n\tvec4 tmp119;\n\tvec4 tmp123;\n\tvec4 tmp127;\n\tvec4 tmp131;\n\tvec3 tmp134;\n\tfloat tmp135;\n\tfloat tmp139;\n\tvec4 tmp143;\n\tvec4 tmp147;\n\tvec4 tmp150;\n\tvec4 tmp152;\n\n\tgeom(varposition, facingnormal, unfinvviewmat, var0, var1, var2, tmp7, tmp8, tmp9, tmp10, tmp11, tmp12, tmp13, tmp14, tmp15);\n\ttexture_image(tmp11, samp0, tmp18, tmp19, tmp20);\n\tsrgb_to_linearrgb(tmp19, tmp22);\n\tmapping(tmp11, cons24, cons25, cons26, cons27, cons28, tmp29);\n\ttexture_image(tmp29, samp1, tmp32, tmp33, tmp34);\n\tsrgb_to_linearrgb(tmp33, tmp36);\n\tmix_mult(cons37, tmp22, tmp36, tmp40);\n\tmix_overlay(cons41, tmp36, cons43, tmp44);\n\tshade_view(varposition, tmp46);\n\tvec_math_normalize(tmp12, tmp48, tmp49);\n\tshade_mul_value(cons50, cons51, tmp52);\n\tset_rgb_zero(tmp53);\n\tlamp_visibility_sun_hemi(unf54, tmp55, tmp56, tmp57);\n\tshade_inp(tmp48, tmp55, tmp60);\n\tshade_visifac(tmp60, tmp57, cons63, tmp64);\n\ttest_shadowbuf_vsm(varposition, samp2, unf67, cons68, cons69, tmp60, tmp71);\n\tshade_mul_value(tmp64, unf73, tmp74);\n\tmtex_value_invert(tmp71, tmp76);\n\tmix_mult(tmp76, tmp74, cons79, tmp80);\n\tmtex_value_invert(tmp76, tmp82);\n\tshade_madd(tmp52, tmp80, cons85, tmp86);\n\tshade_cooktorr_spec(tmp48, tmp55, tmp46, cons90, tmp91);\n\tshade_spec_t(tmp82, cons93, tmp57, tmp91, tmp96);\n\tshade_add_spec(tmp96, unf98, tmp22.rgb, tmp100);\n\tshade_add_clamped(vec4(tmp53, 1.0), vec4(tmp100, 1.0), tmp103);\n\tshade_clamp_positive(tmp103, tmp105);\n\tshade_clamp_positive(tmp86, tmp107);\n\tmix_mult(cons108, tmp105, tmp44, tmp111);\n\tmix_mult(cons112, tmp40, tmp107, tmp115);\n\tmix_add(cons116, tmp115, tmp111, tmp119);\n\tcurves_rgb(cons120, tmp40, samp3, tmp123);\n\tmix_mult(cons124, tmp123, tmp107, tmp127);\n\tmix_add(cons128, tmp127, tmp111, tmp131);\n\tnormal(tmp12, cons133, tmp134, tmp135);\n\tsqueeze(tmp135, cons137, cons138, tmp139);\n\tmix_blend(tmp139, tmp131, tmp119, tmp143);\n\tmix_mult(cons144, tmp143, cons146, tmp147);\n\toutput_node(tmp147, cons149, tmp150);\n\tlinearrgb_to_srgb(tmp150, tmp152);\n\n\tgl_FragColor = tmp152;\n}"},{"name": "simple_action", "channels": [], "type": "ACTION", "markers": {}}]